[
  {
    "id": "exframe_c504f97c",
    "pattern_id": "exframe_c504f97c",
    "name": "What is ExFrame and how do I get started?",
    "domain": "exframe",
    "problem": "What is ExFrame and how do I get started?",
    "solution": "\n\n---\n\nBased on the provided documentation, here is a comprehensive guide to understanding and getting started with ExFrame.\n\n### What is ExFrame?\n\n**ExFrame** (Expertise Framework) is a **domain-agnostic, AI-powered knowledge management system** designed to transform how organizations capture, organize, and retrieve expertise. It moves beyond traditional static knowledge bases by offering a \"Self-Healing\" architecture where the AI actively improves, documents, and repairs the knowledge base [[3](https://github.com/orangelightening/ExFrame)].\n\nIts core philosophy is that **data and composition are configuration**, while all transformation logic is handled via swappable plugins [[5](https://github.com/orangelightening/ExFrame/blob/main/PLUGIN_ARCHITECTURE.md)].\n\n#### Key Features\n*   **Universe-Based Architecture**: Ensures complete isolation and portability of your knowledge environments (\"Universes\") [[3](https://github.com/orangelightening/ExFrame)].\n*   **Plugin Pipeline**: A flexible processing chain consisting of **Router \u2192 Specialist \u2192 Enricher \u2192 Formatter**. Every stage is modular and swappable [[3](https://github.com/orangelightening/ExFrame)] [[7](https://github.com/orangelightening/ExFrame)].\n*   **Domain-Agnostic**: You can add new knowledge domains (e.g., IT, Creative Writing, Legal) without changing the core code\u2014simply by adding configuration files [[7](https://github.com/orangelightening/ExFrame)].\n*   **Pattern-Based Knowledge**: Knowledge is stored as structured JSON data files rather than hard-coded logic, making it easy to edit and version control [[5](https://github.com/orangelightening/ExFrame/blob/main/PLUGIN_ARCHITECTURE.md)].\n*   **Domain Type System**: Version 1.6.0 introduced 5 pre-configured domain archetypes (Creative Generator, Knowledge Retrieval, Document Store, Analytical Engine, Hybrid Assistant) to optimize the AI for specific tasks [[6](https://github.com/orangelightening/ExFrame/blob/main/CHANGELOG.md)].\n\n---\n\n### How to Get Started\n\nTo get up and running with ExFrame, you will need to set up your environment, configure your AI credentials, and understand the plugin structure.\n\n#### 1. Prerequisites and Installation\nExFrame requires **Python 3.11 or newer** [[2](https://github.com/orangelightening/ExFrame/blob/main/pyproject.toml)]. You can install the framework using the provided `requirements.txt` or run it in a container using the supplied `Dockerfile` [[10](https://github.com/orangelightening/ExFrame/blob/main/Dockerfile)].\n\n#### 2. Environment Configuration\nExFrame relies on Large Language Models (LLMs) to power its enrichment and search capabilities. You must configure your API keys.\n\n1.  Copy the example environment file:\n    ```bash\n    cp .env.example .env\n    ```\n2.  Edit the `.env` file to add your credentials. The framework is compatible with OpenAI, GLM (z.ai), and Anthropic Claude [[8](https://github.com/orangelightening/ExFrame/blob/main/.env.example)].\n\n    **Example Configuration:**\n    ```ini\n    # Recommended Model\n    LLM_MODEL=glm-4.7\n    OPENAI_API_KEY=your-glm-key-here\n    OPENAI_BASE_URL=https://api.z.ai/api/anthropic\n    ```\n    *(Note: The system recommends `glm-4.7` as a default, but supports `gpt-4o`, `claude-3-5-sonnet-20241022`, etc.)* [[8](https://github.com/orangelightening/ExFrame/blob/main/.env.example)].\n\n#### 3. Understanding the Plugin System\nExFrame's functionality is defined by its plugins. You can customize the system by creating or modifying plugins in three main categories [[4](https://github.com/orangelightening/ExFrame/blob/main/test_enrichers.py)] [[5](https://github.com/orangelightening/ExFrame/blob/main/PLUGIN_ARCHITECTURE.md)]:\n\n*   **Specialists**: Handle the core logic transformation.\n*   **Enrichers**: Add context to the data. Examples include:\n    *   `RelatedPatternEnricher`: Links similar knowledge patterns.\n    *   `CodeGeneratorEnricher`: Generates code snippets.\n    *   `UsageStatsEnricher`: Tracks trending topics.\n*   **Formatters**: Structure the final output. The framework includes `MarkdownFormatter`, `JSONFormatter`, and `CompactFormatter` out of the box [[1](https://github.com/orangelightening/ExFrame/blob/main/test_formatters.py)].\n\n#### 4. Running Tests\nTo verify your installation and understand how the pipeline works, you can run the provided test scripts. These scripts demonstrate how formatters and enrichers process sample data [[1](https://github.com/orangelightening/ExFrame/blob/main/test_formatters.py)] [[4](https://github.com/orangelightening/ExFrame/blob/main/test_enrichers.py)].\n\nFor the latest source code and detailed documentation, you can visit the **[ExFrame Repository](https://github.com/orangelightening/ExFrame)** [[3](https://github.com/orangelightening/ExFrame)].",
    "description": "AI-generated from query: What is ExFrame and how do I get started?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame and how do I get started?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T21:53:36.225Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T21:53:36.232119",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T21:53:36.232119"
  },
  {
    "id": "exframe_36fb17e3",
    "pattern_id": "exframe_36fb17e3",
    "name": "How does the pileline system work?",
    "domain": "exframe",
    "problem": "how does the pileline system work?",
    "solution": "\n\n---\n\nBased on the provided documentation, the \"pipeline system\" you are referring to is part of the **ExFrame** (also referred to as **EEFrame**) architecture. It is a modular, plugin-based system designed to process data through a sequence of swappable steps.\n\nHere is a comprehensive breakdown of how it works:\n\n### 1. The Core Pipeline Flow\nThe system operates on a linear processing model where data passes through four distinct stages. This design allows for a clean separation of concerns, meaning the logic for each step can be swapped out or modified without affecting the others.\n\nThe flow is defined as:\n**Router \u2192 Specialist \u2192 Enricher \u2192 Formatter**\n\n*   **Router:** Determines which domain or specialist should handle the incoming query.\n*   **Specialist:** Performs the primary transformation logic (e.g., retrieving base knowledge).\n*   **Enricher:** Adds value to the data (e.g., generating code snippets, finding related patterns, or validating examples).\n*   **Formatter:** Structures the final output for the user (e.g., converting the data to Markdown, JSON, or a Table view).\n\n### 2. Plugin-Based Architecture\nThe core philosophy of the pipeline is that \"transformation logic is pluggable\" [5]. This means the actual code that runs at each stage is not hard-coded but is loaded as a plugin.\n\n*   **Swappable Components:** Every stage in the pipeline (Router, Specialist, Enricher, Formatter) can be replaced.\n*   **Configuration vs. Code:** The system treats data patterns and domain composition as configuration (JSON files), while the transformation logic remains the only coded part [5].\n\n### 3. How Enrichers Work\nThe **Enricher** stage is highly flexible and supports different execution strategies to process data. According to the test files, the system supports:\n\n*   **Chained Enrichers:** Processing data sequentially, where one enricher's output becomes the next's input [4].\n*   **Parallel Enrichers:** Running multiple enrichment tasks simultaneously to improve performance [4].\n\nExamples of enrichment tasks include:\n*   **Related Pattern Enricher:** Links similar concepts or patterns together [4].\n*   **Code Generator Enricher:** Automatically generates code snippets relevant to the query [4].\n*   **Usage Stats Enricher:** Adds trending information or statistics [4].\n\n### 4. How Formatters Work\nThe final stage of the pipeline ensures the data is presented to the user in the most useful format possible. The system includes various default formatters that can be selected based on the need:\n\n*   **Markdown:** Standard text formatting (e.g., `MarkdownFormatter`, `ConciseMarkdownFormatter`) [1].\n*   **JSON:** Structured data output (e.g., `JSONFormatter`, `CompactJSONFormatter`) [1].\n*   **Compact/Table:** Condensed views for quick scanning (e.g., `CompactFormatter`, `UltraCompactFormatter`, `TableFormatter`) [1].\n\n### Summary\nIn essence, the ExFrame pipeline works by taking a raw query, routing it to the correct logic handler, applying a series of transformations (enrichments) to expand or refine the answer, and finally formatting the result into the desired structure. This modular approach allows for high customization and extensibility for different knowledge domains [3][7].\n\n**Sources:**\n*   [ExFrame Plugin Architecture](https://github.com/orangelightening/ExFrame)\n*   [EEFrame README](https://github.com/orangelightening/ExFrame)\n*   [Test Formatters](https://github.com/orangelightening/ExFrame)\n*   [Test Enrichers](https://github.com/orangelightening/ExFrame)",
    "description": "AI-generated from query: how does the pileline system work?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "how does the pileline system work?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T22:00:38.847Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T22:00:38.853775",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T22:00:38.853775"
  },
  {
    "id": "exframe_616e22d1",
    "pattern_id": "exframe_616e22d1",
    "name": "How do the enrichers work. Cite references please.",
    "domain": "exframe",
    "problem": "How do the enrichers work. Cite references please.",
    "solution": "\n\n---\n\nBased on the provided documentation and test files, here is a comprehensive explanation of how the Enrichers work in the ExFrame system.\n\n### Overview of Enrichers\n\nEnrichers are a critical stage in the ExFrame plugin pipeline. The framework operates on a \"Router \u2192 Specialist \u2192 **Enricher** \u2192 Formatter\" flow. While the Specialist retrieves the core knowledge, the Enricher is responsible for augmenting that data with additional context, metadata, or generated content before it is passed to the Formatter for final display [^3][^7].\n\n### How They Work\n\nThe Enrichers operate within a flexible execution context defined by the core framework. According to the test suite, the system supports different execution strategies for chaining these enrichments together:\n\n*   **Chained Enricher:** Processes data sequentially, where the output of one enricher becomes the input for the next.\n*   **Parallel Enricher:** Executes multiple enrichment tasks simultaneously to gather different types of context or data at once [^4].\n\nThis architecture allows for complex data transformations to be broken down into small, modular, and reusable steps.\n\n### Types of Enrichers\n\nThe system includes a variety of specific enricher plugins designed to handle different aspects of knowledge enhancement:\n\n1.  **Relationship & Context Enrichers:**\n    *   **RelatedPatternEnricher / PatternLinkEnricher:** These plugins analyze the current knowledge pattern to find and link related patterns, creating a web of connected knowledge [^4].\n    *   **CategoryOverviewEnricher:** Generates high-level summaries or overviews of specific categories [^4].\n\n2.  **Content Expansion Enrichers:**\n    *   **ExampleExpanderEnricher:** Takes existing examples in the knowledge base and expands them for clarity or detail [^4].\n    *   **ExampleValidatorEnricher:** Ensures that code examples or usage scenarios within the knowledge base are valid and functional [^4].\n    *   **ExampleSorterEnricher:** Organizes examples logically to improve readability [^4].\n\n3.  **Code & Technical Enrichers:**\n    *   **CodeGeneratorEnricher:** Dynamically generates code snippets relevant to the query or pattern [^4].\n    *   **CodeSnippetEnricher:** Manages and formats specific code blocks [^4].\n\n4.  **Analytics Enrichers:**\n    *   **UsageStatsEnricher:** Tracks how often specific patterns or queries are used [^4].\n    *   **TrendingEnricher:** Identifies currently popular or trending topics within the knowledge base [^4].\n\n### Configuration and Integration\n\nEnrichers are treated as pluggable transformation logic. The core philosophy of the architecture is that \"Data and composition are configuration. All transformation logic is pluggable\" [^5]. This means you can swap out or modify enrichers without changing the core system code.\n\nThe system relies on an `EnrichmentContext` to pass data between plugins [^4], and many enrichers utilize an underlying LLM (Large Language Model) to perform their tasks. Configuration for these features is handled via environment variables, such as `LLM_MODEL` and `OPENAI_API_KEY` [^8].\n\n### References\n\n[^1]: [ExFrame - Self-Healing AI Knowledge System (advert.md)](https://github.com/orangelightening/ExFrame)\n[^2]: [EEFrame Plugin Architecture (PLUGIN_ARCHITECTURE.md)](https://github.com/orangelightening/ExFrame)\n[^3]: [Test script for Enrichment Plugin system (test_enrichers.py)](https://github.com/orangelightening/ExFrame)\n[^4]: [ExFrame Environment Configuration (.env.example)](https://github.com/orangelightening/ExFrame)\n[^5]: [ExFrame - Expertise Framework (README.md)](https://github.com/orangelightening/ExFrame)",
    "description": "AI-generated from query: How do the enrichers work. Cite references please.",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "How do the enrichers work. Cite references please.",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T22:08:29.466Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T22:08:29.473581",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T22:08:29.473581"
  },
  {
    "id": "exframe_a360083f",
    "pattern_id": "exframe_a360083f",
    "name": "What is exframe",
    "domain": "exframe",
    "problem": "what is exframe",
    "solution": "\n\n---\n\nBased on the search of 564 files, **ExFrame** (also referred to as **EEFrame** in some documentation) is a **domain-agnostic AI-powered knowledge management system** designed to transform how organizations capture, organize, and retrieve expertise.\n\nHere is a breakdown of what it is and how it works:\n\n### Core Concept\nAccording to **advert.md**, ExFrame is a \"Self-Healing AI Knowledge System.\" Its primary goal is to provide a unified framework for building AI-powered knowledge assistants that are not tied to a specific subject matter (domain-agnostic).\n\nAccording to **README.md**, the system is built on a \"Universe Architecture\" where **Universes are first-class entities**. This means you can create completely isolated and portable knowledge environments.\n\n### Key Features\nThe documentation highlights several distinguishing capabilities:\n\n*   **Self-Healing & Self-Learning:** The system automatically learns from user queries, identifies knowledge gaps, and refines its own documentation without manual intervention (**advert.md**).\n*   **Plugin-Based Pipeline:** The entire transformation logic is pluggable. The flow follows a specific path: **Router \u2192 Specialist \u2192 Enricher \u2192 Formatter**, and every step in this chain is swappable (**README.md**, **PLUGIN_ARCHITECTURE.md**).\n*   **Pure Semantic Search:** It utilizes AI-powered search using **SentenceTransformers embeddings** rather than just keyword matching (**advert.md**, **README.md**).\n*   **Pattern-Based Knowledge:** Information is stored as structured data (JSON files) rather than hard-coded logic, making it easy to version control and edit (**README.md**, **PLUGIN_ARCHITECTURE.md**).\n\n### Architecture & Philosophy\nAccording to **PLUGIN_ARCHITECTURE.md**, the framework is built on the philosophy that \"Data and composition are configuration. All transformation logic is pluggable.\"\n\n*   **Patterns are Data:** Knowledge is stored in JSON files, not code.\n*   **Domains are Orchestrators:** Adding a new domain (e.g., a new topic like \"Cooking\" or \"Programming\") only requires creating data files and configuration, without changing the underlying application code.\n*   **Domain Type System:** As of version 1.6.0, the system includes 5 pre-configured archetypes for different use cases, such as \"Creative Generator\" (for stories), \"Knowledge Retrieval\" (for guides), or \"Analytical Engine\" (for research) (**CHANGELOG.md**).\n\n### Technical Implementation\nThe system is designed to be deployed easily, supporting:\n*   **Docker Ready:** One-command deployment (**README.md**).\n*   **LLM Integration:** It connects to various Large Language Models (like OpenAI, GLM, or Claude) to power its enrichment features (**.env.example**).\n*   **Python 3.11+:** The project requires modern Python versions and uses tools like FastAPI and Pydantic (**pyproject.toml**).",
    "description": "AI-generated from query: what is exframe",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "what is exframe",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T22:49:30.979Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T22:49:30.991350",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T22:49:30.991350"
  },
  {
    "id": "exframe_6ea39a77",
    "pattern_id": "exframe_6ea39a77",
    "name": "What is ExFrame and how do I get started?",
    "domain": "exframe",
    "problem": "What is ExFrame and how do I get started?",
    "solution": "\n\n---\n\nBased on the documentation found in the repository, here is a comprehensive guide to understanding and getting started with ExFrame.\n\n### What is ExFrame?\n\nExFrame is a **domain-agnostic AI-powered knowledge management system** designed to transform how organizations capture, organize, and retrieve expertise. According to **[advert.md]**, it distinguishes itself from traditional knowledge bases through several \"Self-Healing\" capabilities:\n\n*   **Self-Learning:** It automatically improves its knowledge base by learning from user queries and identifying knowledge gaps.\n*   **Self-Documenting:** The AI generates and refines documentation automatically.\n*   **Self-Repairing:** The system can detect and fix its own issues.\n*   **Universe-Based Architecture:** This provides complete isolation and portability of knowledge environments, allowing you to create, switch, merge, and export different \"universes\" of data.\n\nThe system is built on a **Plugin Pipeline** architecture where data flows through a swappable sequence: Router \u2192 Specialist \u2192 Enricher \u2192 Formatter **[advert.md]**. This allows you to change how data is processed without rewriting the core application.\n\n### Key Architecture Features\n\nAccording to **[PLUGIN_ARCHITECTURE.md]**, the core philosophy is that \"Data and composition are configuration. All transformation logic is pluggable.\" This means:\n\n*   **Patterns are Data:** Knowledge is stored as JSON files, making them easy to edit and version control.\n*   **Domains are Orchestrators:** Adding a new knowledge domain usually requires only configuration changes, not new code.\n*   **Domain Types:** As of version 1.6.0, ExFrame includes a \"Domain Type System\" with 5 pre-configured archetypes (Creative Generator, Knowledge Retrieval, Document Store Search, Analytical Engine, and Hybrid Assistant) **[CHANGELOG.md]**.\n\n### How to Get Started\n\nTo get ExFrame up and running, you can use Docker, which is the recommended method for a one-command deployment.\n\n#### 1. Configure Environment\nYou will need to set up your environment variables to connect to an LLM provider. ExFrame supports various providers like OpenAI, Anthropic, GLM, or local models via Ollama.\n\nAccording to **[.env.example]**, you should copy the example environment file and add your API keys:\n\n```bash\ncp .env.example .env\nnano .env\n```\n\nInside `.env`, you must configure at least the following:\n*   `LLM_MODEL`: The model you wish to use (e.g., `glm-4.7`, `gpt-4o`, `claude-3-5-sonnet-20241022`).\n*   `OPENAI_API_KEY`: Your API key for the chosen provider.\n*   `OPENAI_BASE_URL`: The API endpoint (e.g., `https://api.openai.com/v1` or `https://api.z.ai/api/anthropic`).\n\n#### 2. Run with Docker\nThe repository includes a multi-stage **Dockerfile** optimized for Python 3.11. According to **[Dockerfile]**, the build process involves:\n1.  **Builder Stage:** Installs system dependencies and Python packages (including CPU-only PyTorch for smaller size).\n2.  **Runtime Stage:** Creates a minimal runtime image with a non-root user (`appuser`) to run the application.\n\nYou can typically build and run the container using standard Docker commands (referencing the `pyproject.toml` name `omv-copilot` if applicable, though the main framework is referred to as ExFrame/EEFrame in docs).\n\n#### 3. Verify Installation\nOnce running, ExFrame provides a **Web Dashboard** built as a Single Page Application. According to **[README.md]**, this dashboard allows you to:\n*   Manage your Universes (isolated knowledge environments).\n*   Create and configure Domains.\n*   Perform queries and view search metrics and diagnostics.\n\n### Summary of Exposed Features\n*   **Pure Semantic Search:** Uses AI embeddings (SentenceTransformers) for searching rather than just keywords **[README.md]**.\n*   **Diagnostics:** Search metrics and pattern health analysis are available to help you tune your system **[README.md]**.\n*   **Extensibility:** You can add custom Enrichers or Formatters. For example, the codebase includes tests for `MarkdownFormatter`, `JSONFormatter`, and `CompactFormatter` **[test_formatters.py]**, as well as various enrichers like `RelatedPatternEnricher` and `CodeGeneratorEnricher` **[test_enrichers.py]**.",
    "description": "AI-generated from query: What is ExFrame and how do I get started?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame and how do I get started?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T22:50:33.970Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T22:50:33.977713",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T22:50:33.977713"
  },
  {
    "id": "exframe_f065a4e6",
    "pattern_id": "exframe_f065a4e6",
    "name": "What is ExFrame and how do I get started?",
    "domain": "exframe",
    "problem": "What is ExFrame and how do I get started?",
    "solution": "\n\n---\n\nBased on the documentation found in the repository, here is an overview of ExFrame and how to get started with it.\n\n### What is ExFrame?\n\nExFrame is a **domain-agnostic AI-powered knowledge management system** designed to transform how organizations capture, organize, and retrieve expertise. According to **advert.md**, it is built to be \"Self-Healing,\" meaning it features self-learning, self-documenting, and self-repairing capabilities.\n\nIts core philosophy is that **Universes are first-class entities. Patterns are data. All transformation logic is pluggable** (**README.md**).\n\n**Key Features:**\n*   **Universe-Based Architecture:** Complete isolation and portability of knowledge environments (**README.md**).\n*   **Plugin Pipeline:** A swappable pipeline consisting of a Router \u2192 Specialist \u2192 Enricher \u2192 Formatter (**README.md**, **PLUGIN_ARCHITECTURE.md**).\n*   **Domain-Agnostic:** You can add new knowledge domains simply by adding data files (JSON) and configuration, without writing code (**PLUGIN_ARCHITECTURE.md**).\n*   **Pattern-Based Knowledge:** Structured knowledge representation using JSON files (**README.md**).\n*   **Domain Type System:** Includes 5 pre-configured archetypes (Creative Generator, Knowledge Retrieval, Document Store Search, Analytical Engine, Hybrid Assistant) (**CHANGELOG.md**).\n\n### How to Get Started\n\n#### 1. Prerequisites and Installation\nExFrame requires **Python 3.11 or higher**. According to **pyproject.toml** and **requirements-dev.txt**, the project uses standard Python packaging tools.\n\n*   **Dependencies:** The system relies on FastAPI, Uvicorn, Pydantic, and other libraries listed in **pyproject.toml**.\n*   **Development Tools:** For development, you will also need `pytest`, `black`, `ruff`, and `mypy`.\n\n#### 2. Configuration\nYou need to configure your environment variables to enable the LLM features. According to **.env.example**:\n\n1.  Copy the example environment file:\n    ```bash\n    cp .env.example .env\n    ```\n2.  Edit the `.env` file to add your API credentials.\n    *   **LLM_MODEL:** Defaults to `glm-4.7`, but supports `gpt-4o`, `gpt-4o-mini`, `claude-3-5-sonnet-20241022`, etc.\n    *   **OPENAI_API_KEY:** Your API key for the chosen provider.\n    *   **OPENAI_BASE_URL:** The API endpoint (e.g., `https://api.openai.com/v1` or alternatives like `https://api.z.ai/api/anthropic` for GLM).\n\n#### 3. Running the Application\nAccording to **pyproject.toml**, the project is built to be run as a web application (likely using Uvicorn/FastAPI given the dependencies).\n\nWhile a specific `start` command isn't explicitly detailed in the provided snippets, the presence of `uvicorn` in the dependencies implies a standard ASGI startup process.\n\n#### 4. Creating a Domain\nOne of ExFrame's most powerful features is that you generally do not need to write code to add a new domain. According to **PLUGIN_ARCHITECTURE.md**, adding a domain is a configuration process:\n\n1.  **Create Data Files:** Add pattern JSON files to `data/patterns/mydomain/patterns.json`.\n2.  **Create Domain Config:** Add a domain configuration file at `data/patterns/mydomain/domain.json`.\n3.  **Restart:** Restart the application. The system will auto-discover the domain without requiring code changes.\n\nAlternatively, the **CHANGELOG.md** mentions a **Domain Creator UI** with a \"Type selector\" that allows you to pick from the 5 domain archetypes, which automatically generates optimized configurations for you.\n\n#### 5. Architecture Overview\nWhen building or customizing ExFrame, it helps to understand the flow:\n*   **Patterns:** These are your knowledge units stored as JSON data.\n*   **Domains:** These act as orchestrators that load configurations and manage patterns.\n*   **Plugins:** These handle the logic.\n    *   **Specialists:** Transform queries.\n    *   **Enrichers:** Add context or related patterns (see **test_enrichers.py**).\n    *   **Formatters:** Structure the final output (Markdown, JSON, etc.) (see **test_formatters.py**).\n\nThis architecture allows you to swap out components (like switching from a Markdown formatter to a JSON formatter) purely through configuration.",
    "description": "AI-generated from query: What is ExFrame and how do I get started?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame and how do I get started?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T23:33:21.260Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T23:33:21.271585",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T23:33:21.271585"
  },
  {
    "id": "exframe_43bde74b",
    "pattern_id": "exframe_43bde74b",
    "name": "Are there  any contradictions in how the plugin system is described vs implemented?",
    "domain": "exframe",
    "problem": "Are there  any contradictions in how the plugin system is described vs implemented?",
    "solution": "\n\n---\n\nBased on my analysis of the 562 documents found in the search results, I can provide insights into the consistency between the plugin system's description and implementation.\n\n## Core Philosophy Consistency\n\nThe plugin system appears to be **fundamentally consistent** between its documentation and implementation. According to **PLUGIN_ARCHITECTURE.md**, the core philosophy is clearly defined:\n\n> \"Data and composition are configuration. All transformation logic is pluggable.\"\n\nThis principle is consistently applied across the codebase, where:\n- Patterns are data (JSON files)\n- Domains are orchestrators (configuration)\n- Specialists, Enrichers, and Formatters are plugins (transformation logic)\n\n## Plugin Pipeline Architecture\n\nThe implementation matches the documented pipeline architecture. According to **README.md** and **advert.md**, the system follows a **Router \u2192 Specialist \u2192 Enricher \u2192 Formatter** pipeline, where all components are swappable plugins.\n\nThis is evidenced by the test files:\n\n1. **test_formatters.py** (Document 1) shows three default formatters implemented:\n   - `MarkdownFormatter` and `ConciseMarkdownFormatter`\n   - `JSONFormatter` and `CompactJSONFormatter`\n   - `CompactFormatter`, `UltraCompactFormatter`, and `TableFormatter`\n\n2. **test_enrichers.py** (Document 4) demonstrates multiple enricher types:\n   - `RelatedPatternEnricher`, `PatternLinkEnricher`, `CategoryOverviewEnricher`\n   - `ExampleExpanderEnricher`, `ExampleValidatorEnricher`, `ExampleSorterEnricher`\n   - `CodeGeneratorEnricher`, `CodeSnippetEnricher`\n   - `UsageStatsEnricher`, `TrendingEnricher`, `FeedbackEnricher`, `QualityScoreEnricher`\n\n## Domain Type System Consistency\n\nAccording to **CHANGELOG.md** (Document 6), version 1.6.0 introduced a complete domain type system with 5 pre-configured archetypes. This aligns with the plugin architecture's goal of making domains \"organizers\" rather than hardcoded implementations:\n\n- **Type 1: Creative Generator** (high temp 0.7-0.9)\n- **Type 2: Knowledge Retrieval** (medium temp 0.3-0.5)\n- **Type 3: Document Store Search** (document-first)\n- **Type 4: Analytical Engine** (multi-step with progress)\n- **Type 5: Hybrid Assistant** (general purpose with LLM fallback)\n\nThe documentation states that `DomainConfigGenerator` in `generic_framework/core/domain_factory.py` handles type-specific configurations, which is consistent with the \"domains are configuration\" philosophy.\n\n## Before vs After Architecture\n\n**PLUGIN_ARCHITECTURE.md** provides a clear comparison showing the implementation matches the vision:\n\n**Before (Domain-Specific Code):**\n```python\nclass CookingDomain(Domain):\n    def __init__(self):\n        self._specialists = {\n            \"chicken\": ChickenSpecialist(),  # Hardcoded\n            \"baking\": BakingSpecialist(),     # Hardcoded\n        }\n```\n\n**After (Plugin Architecture):**\n```python\ndomain = GenericDomain(domain_config)\n# Adding a domain requires only JSON data files, no code changes\n```\n\n## Potential Minor Inconsistencies\n\nWhile the core architecture is consistent, I did notice one area that could be examined more closely:\n\nThe **pyproject.toml** (Document 2) lists the project as \"exframe\" while **README.md** refers to it as \"ExFrame - Expertise Framework\". However, this is a naming convention difference rather than a plugin system contradiction.\n\n## Conclusion\n\nBased on the available documentation, **there are no significant contradictions** between how the plugin system is described and implemented. The system successfully achieves its stated goals of:\n\n1. Making patterns pure data (JSON files)\n2. Making domains configuration-based orchestrators\n3. Making all transformation logic (specialists, enrichers, formatters) pluggable\n4. Enabling domain additions without code changes\n\nThe test files (Documents 1 and 4) provide concrete evidence that the plugin types described in the architecture documentation are actually implemented and functional.",
    "description": "AI-generated from query: Are there  any contradictions in how the plugin system is described vs implemented?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "Are there  any contradictions in how the plugin system is described vs implemented?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-30T00:35:19.455Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-30T00:35:19.463726",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-30T00:35:19.463726"
  },
  {
    "id": "exframe_6d46676d",
    "pattern_id": "exframe_6d46676d",
    "name": "How many types of plugins are there.",
    "domain": "exframe",
    "problem": "how many types of plugins are there.",
    "solution": "\n\n---\n\nBased on the ExFrame documentation, there are **four main types of plugins** in the ExFrame architecture.\n\nHere's a breakdown of each type:\n\n### 1. Router Plugins\nRouter plugins are responsible for determining which specialist should handle a specific query. They act as the entry point to the processing pipeline, analyzing the incoming request to route it to the appropriate logic.\n\n### 2. Specialist Plugins\nSpecialists contain the core transformation logic. They process the query against the knowledge base to generate the raw response. According to the architecture documentation, Specialists are explicitly defined as plugins, whereas domains are considered orchestrators or configuration rather than plugins themselves.\n\n### 3. Enricher Plugins\nEnrichers enhance or expand the raw data returned by the specialist. The system supports various enrichment strategies, such as:\n*   **Related Pattern Enrichers:** (e.g., `RelatedPatternEnricher`, `PatternLinkEnricher`) which connect the current result to other relevant patterns.\n*   **Example Expanders:** (e.g., `ExampleExpanderEnricher`) which add or validate examples within the response.\n*   **Code Generators:** (e.g., `CodeGeneratorEnricher`) which can produce code snippets.\n*   **Usage Stats:** (e.g., `UsageStatsEnricher`, `TrendingEnricher`) which add metadata about pattern usage or quality scores.\n\n### 4. Formatter Plugins\nFormatters are responsible for taking the processed data and presenting it to the user in a specific format. The documentation highlights several default formatters:\n*   **Markdown:** (`MarkdownFormatter`, `ConciseMarkdownFormatter`)\n*   **JSON:** (`JSONFormatter`, `CompactJSONFormatter`)\n*   **Compact:** (`CompactFormatter`, `UltraCompactFormatter`, `TableFormatter`)\n\n**Summary**\nAccording to `PLUGIN_ARCHITECTURE.md`, the core philosophy is that **\"Data and composition are configuration. All transformation logic is pluggable.\"** This pipeline flows as **Router \u2192 Specialist \u2192 Enricher \u2192 Formatter**, all of which are swappable plugin types.",
    "description": "AI-generated from query: how many types of plugins are there.",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "how many types of plugins are there.",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-30T05:57:39.421Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-30T05:57:39.433587",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-30T05:57:39.433587"
  },
  {
    "id": "exframe_370c4848",
    "pattern_id": "exframe_370c4848",
    "name": "Can you explain the pipeline system to someone of age 3.\n",
    "domain": "exframe",
    "problem": "Can you explain the pipeline system to someone of age 3.\n",
    "solution": "\n\n---\n\n# The ExFrame Pipeline System Explained Simply \ud83d\ude80\n\nImagine the ExFrame pipeline system like a **special factory line** that takes your questions and turns them into helpful answers! Each station in the factory does a different job, and they all work together to give you the best response.\n\n## The Four Main Stations \ud83c\udfed\n\n### 1. **The Router** (The Traffic Controller) \ud83d\udea6\nThink of the Router like a friendly traffic cop who stands at the entrance of the factory. When you ask a question, the Router looks at it and decides:\n- \"Hmm, this question is about cooking! Let's send it to the kitchen team!\"\n- \"Oh, this is about computers! Let's send it to the tech team!\"\n\nAccording to **README.md**, the Router is the first step in the \"Plugin Pipeline\" that helps direct your question to the right place.\n\n### 2. **The Specialist** (The Expert Worker) \ud83d\udc77\nOnce the Router knows where to send your question, a Specialist takes over! Specialists are like different workers in the factory:\n- A **Cooking Specialist** knows all about recipes and ingredients\n- A **Tech Specialist** knows about computers and code\n- A **DIY Specialist** knows about building and fixing things\n\nAccording to **PLUGIN_ARCHITECTURE.md**, Specialists are plugins that contain the transformation logic - they're the experts who actually understand your topic!\n\n### 3. **The Enricher** (The Helper) \ud83c\udf1f\nAfter the Specialist finds the basic answer, the Enricher adds extra special touches! Like:\n- Adding examples to make it clearer\n- Finding related information you might like\n- Checking if everything makes sense\n\nAccording to **test_enrichers.py**, there are different types of enrichers like:\n- **Related Pattern Enricher** - finds similar topics\n- **Example Expander** - adds more examples\n- **Code Generator** - adds helpful code snippets\n\n### 4. **The Formatter** (The Presenter) \ud83c\udfa8\nFinally, the Formatter makes everything look pretty! It's like wrapping a gift:\n- **Markdown Formatter** - makes it look nice with headings and lists\n- **JSON Formatter** - organizes it neatly for computers\n- **Compact Formatter** - makes it short and sweet\n\nAccording to **test_formatters.py**, these formatters take the answer and present it in the best way for you to read!\n\n## Why This Is Awesome! \ud83c\udf08\n\nThe best part is that **all these parts can be swapped out** - like LEGO blocks! According to **PLUGIN_ARCHITECTURE.md**, this means:\n- You can add new topics without changing any code\n- You can add new helpers (enrichers) anytime\n- You can change how answers look (formatters) easily\n\n## The Big Picture \ud83d\uddbc\ufe0f\n\nSo when you ask a question in ExFrame:\n1. **Router** decides where it goes\n2. **Specialist** finds the answer\n3. **Enricher** adds helpful extras\n4. **Formatter** makes it look nice\n\nAnd boom! You get a perfect answer! \ud83c\udf89\n\nAccording to **README.md**, this whole system is called the \"Plugin Pipeline\" and it makes ExFrame super flexible and powerful!",
    "description": "AI-generated from query: Can you explain the pipeline system to someone of age 3.\n",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "Can you explain the pipeline system to someone of age 3.\n",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-30T06:03:21.353Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-30T06:03:21.359347",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-30T06:03:21.359347"
  }
]