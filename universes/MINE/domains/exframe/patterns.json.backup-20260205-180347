[
  {
    "id": "exframe_c504f97c",
    "pattern_id": "exframe_c504f97c",
    "name": "What is ExFrame and how do I get started?",
    "domain": "exframe",
    "problem": "What is ExFrame and how do I get started?",
    "solution": "\n\n---\n\nBased on the provided documentation, here is a comprehensive guide to understanding and getting started with ExFrame.\n\n### What is ExFrame?\n\n**ExFrame** (Expertise Framework) is a **domain-agnostic, AI-powered knowledge management system** designed to transform how organizations capture, organize, and retrieve expertise. It moves beyond traditional static knowledge bases by offering a \"Self-Healing\" architecture where the AI actively improves, documents, and repairs the knowledge base [[3](https://github.com/orangelightening/ExFrame)].\n\nIts core philosophy is that **data and composition are configuration**, while all transformation logic is handled via swappable plugins [[5](https://github.com/orangelightening/ExFrame/blob/main/PLUGIN_ARCHITECTURE.md)].\n\n#### Key Features\n*   **Universe-Based Architecture**: Ensures complete isolation and portability of your knowledge environments (\"Universes\") [[3](https://github.com/orangelightening/ExFrame)].\n*   **Plugin Pipeline**: A flexible processing chain consisting of **Router \u2192 Specialist \u2192 Enricher \u2192 Formatter**. Every stage is modular and swappable [[3](https://github.com/orangelightening/ExFrame)] [[7](https://github.com/orangelightening/ExFrame)].\n*   **Domain-Agnostic**: You can add new knowledge domains (e.g., IT, Creative Writing, Legal) without changing the core code\u2014simply by adding configuration files [[7](https://github.com/orangelightening/ExFrame)].\n*   **Pattern-Based Knowledge**: Knowledge is stored as structured JSON data files rather than hard-coded logic, making it easy to edit and version control [[5](https://github.com/orangelightening/ExFrame/blob/main/PLUGIN_ARCHITECTURE.md)].\n*   **Domain Type System**: Version 1.6.0 introduced 5 pre-configured domain archetypes (Creative Generator, Knowledge Retrieval, Document Store, Analytical Engine, Hybrid Assistant) to optimize the AI for specific tasks [[6](https://github.com/orangelightening/ExFrame/blob/main/CHANGELOG.md)].\n\n---\n\n### How to Get Started\n\nTo get up and running with ExFrame, you will need to set up your environment, configure your AI credentials, and understand the plugin structure.\n\n#### 1. Prerequisites and Installation\nExFrame requires **Python 3.11 or newer** [[2](https://github.com/orangelightening/ExFrame/blob/main/pyproject.toml)]. You can install the framework using the provided `requirements.txt` or run it in a container using the supplied `Dockerfile` [[10](https://github.com/orangelightening/ExFrame/blob/main/Dockerfile)].\n\n#### 2. Environment Configuration\nExFrame relies on Large Language Models (LLMs) to power its enrichment and search capabilities. You must configure your API keys.\n\n1.  Copy the example environment file:\n    ```bash\n    cp .env.example .env\n    ```\n2.  Edit the `.env` file to add your credentials. The framework is compatible with OpenAI, GLM (z.ai), and Anthropic Claude [[8](https://github.com/orangelightening/ExFrame/blob/main/.env.example)].\n\n    **Example Configuration:**\n    ```ini\n    # Recommended Model\n    LLM_MODEL=glm-4.7\n    OPENAI_API_KEY=your-glm-key-here\n    OPENAI_BASE_URL=https://api.z.ai/api/anthropic\n    ```\n    *(Note: The system recommends `glm-4.7` as a default, but supports `gpt-4o`, `claude-3-5-sonnet-20241022`, etc.)* [[8](https://github.com/orangelightening/ExFrame/blob/main/.env.example)].\n\n#### 3. Understanding the Plugin System\nExFrame's functionality is defined by its plugins. You can customize the system by creating or modifying plugins in three main categories [[4](https://github.com/orangelightening/ExFrame/blob/main/test_enrichers.py)] [[5](https://github.com/orangelightening/ExFrame/blob/main/PLUGIN_ARCHITECTURE.md)]:\n\n*   **Specialists**: Handle the core logic transformation.\n*   **Enrichers**: Add context to the data. Examples include:\n    *   `RelatedPatternEnricher`: Links similar knowledge patterns.\n    *   `CodeGeneratorEnricher`: Generates code snippets.\n    *   `UsageStatsEnricher`: Tracks trending topics.\n*   **Formatters**: Structure the final output. The framework includes `MarkdownFormatter`, `JSONFormatter`, and `CompactFormatter` out of the box [[1](https://github.com/orangelightening/ExFrame/blob/main/test_formatters.py)].\n\n#### 4. Running Tests\nTo verify your installation and understand how the pipeline works, you can run the provided test scripts. These scripts demonstrate how formatters and enrichers process sample data [[1](https://github.com/orangelightening/ExFrame/blob/main/test_formatters.py)] [[4](https://github.com/orangelightening/ExFrame/blob/main/test_enrichers.py)].\n\nFor the latest source code and detailed documentation, you can visit the **[ExFrame Repository](https://github.com/orangelightening/ExFrame)** [[3](https://github.com/orangelightening/ExFrame)].",
    "description": "AI-generated from query: What is ExFrame and how do I get started?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame and how do I get started?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T21:53:36.225Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T21:53:36.232119",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T21:53:36.232119"
  },
  {
    "id": "exframe_36fb17e3",
    "pattern_id": "exframe_36fb17e3",
    "name": "How does the pileline system work?",
    "domain": "exframe",
    "problem": "how does the pileline system work?",
    "solution": "\n\n---\n\nBased on the provided documentation, the \"pipeline system\" you are referring to is part of the **ExFrame** (also referred to as **EEFrame**) architecture. It is a modular, plugin-based system designed to process data through a sequence of swappable steps.\n\nHere is a comprehensive breakdown of how it works:\n\n### 1. The Core Pipeline Flow\nThe system operates on a linear processing model where data passes through four distinct stages. This design allows for a clean separation of concerns, meaning the logic for each step can be swapped out or modified without affecting the others.\n\nThe flow is defined as:\n**Router \u2192 Specialist \u2192 Enricher \u2192 Formatter**\n\n*   **Router:** Determines which domain or specialist should handle the incoming query.\n*   **Specialist:** Performs the primary transformation logic (e.g., retrieving base knowledge).\n*   **Enricher:** Adds value to the data (e.g., generating code snippets, finding related patterns, or validating examples).\n*   **Formatter:** Structures the final output for the user (e.g., converting the data to Markdown, JSON, or a Table view).\n\n### 2. Plugin-Based Architecture\nThe core philosophy of the pipeline is that \"transformation logic is pluggable\" [5]. This means the actual code that runs at each stage is not hard-coded but is loaded as a plugin.\n\n*   **Swappable Components:** Every stage in the pipeline (Router, Specialist, Enricher, Formatter) can be replaced.\n*   **Configuration vs. Code:** The system treats data patterns and domain composition as configuration (JSON files), while the transformation logic remains the only coded part [5].\n\n### 3. How Enrichers Work\nThe **Enricher** stage is highly flexible and supports different execution strategies to process data. According to the test files, the system supports:\n\n*   **Chained Enrichers:** Processing data sequentially, where one enricher's output becomes the next's input [4].\n*   **Parallel Enrichers:** Running multiple enrichment tasks simultaneously to improve performance [4].\n\nExamples of enrichment tasks include:\n*   **Related Pattern Enricher:** Links similar concepts or patterns together [4].\n*   **Code Generator Enricher:** Automatically generates code snippets relevant to the query [4].\n*   **Usage Stats Enricher:** Adds trending information or statistics [4].\n\n### 4. How Formatters Work\nThe final stage of the pipeline ensures the data is presented to the user in the most useful format possible. The system includes various default formatters that can be selected based on the need:\n\n*   **Markdown:** Standard text formatting (e.g., `MarkdownFormatter`, `ConciseMarkdownFormatter`) [1].\n*   **JSON:** Structured data output (e.g., `JSONFormatter`, `CompactJSONFormatter`) [1].\n*   **Compact/Table:** Condensed views for quick scanning (e.g., `CompactFormatter`, `UltraCompactFormatter`, `TableFormatter`) [1].\n\n### Summary\nIn essence, the ExFrame pipeline works by taking a raw query, routing it to the correct logic handler, applying a series of transformations (enrichments) to expand or refine the answer, and finally formatting the result into the desired structure. This modular approach allows for high customization and extensibility for different knowledge domains [3][7].\n\n**Sources:**\n*   [ExFrame Plugin Architecture](https://github.com/orangelightening/ExFrame)\n*   [EEFrame README](https://github.com/orangelightening/ExFrame)\n*   [Test Formatters](https://github.com/orangelightening/ExFrame)\n*   [Test Enrichers](https://github.com/orangelightening/ExFrame)",
    "description": "AI-generated from query: how does the pileline system work?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "how does the pileline system work?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T22:00:38.847Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T22:00:38.853775",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T22:00:38.853775"
  },
  {
    "id": "exframe_616e22d1",
    "pattern_id": "exframe_616e22d1",
    "name": "How do the enrichers work. Cite references please.",
    "domain": "exframe",
    "problem": "How do the enrichers work. Cite references please.",
    "solution": "\n\n---\n\nBased on the provided documentation and test files, here is a comprehensive explanation of how the Enrichers work in the ExFrame system.\n\n### Overview of Enrichers\n\nEnrichers are a critical stage in the ExFrame plugin pipeline. The framework operates on a \"Router \u2192 Specialist \u2192 **Enricher** \u2192 Formatter\" flow. While the Specialist retrieves the core knowledge, the Enricher is responsible for augmenting that data with additional context, metadata, or generated content before it is passed to the Formatter for final display [^3][^7].\n\n### How They Work\n\nThe Enrichers operate within a flexible execution context defined by the core framework. According to the test suite, the system supports different execution strategies for chaining these enrichments together:\n\n*   **Chained Enricher:** Processes data sequentially, where the output of one enricher becomes the input for the next.\n*   **Parallel Enricher:** Executes multiple enrichment tasks simultaneously to gather different types of context or data at once [^4].\n\nThis architecture allows for complex data transformations to be broken down into small, modular, and reusable steps.\n\n### Types of Enrichers\n\nThe system includes a variety of specific enricher plugins designed to handle different aspects of knowledge enhancement:\n\n1.  **Relationship & Context Enrichers:**\n    *   **RelatedPatternEnricher / PatternLinkEnricher:** These plugins analyze the current knowledge pattern to find and link related patterns, creating a web of connected knowledge [^4].\n    *   **CategoryOverviewEnricher:** Generates high-level summaries or overviews of specific categories [^4].\n\n2.  **Content Expansion Enrichers:**\n    *   **ExampleExpanderEnricher:** Takes existing examples in the knowledge base and expands them for clarity or detail [^4].\n    *   **ExampleValidatorEnricher:** Ensures that code examples or usage scenarios within the knowledge base are valid and functional [^4].\n    *   **ExampleSorterEnricher:** Organizes examples logically to improve readability [^4].\n\n3.  **Code & Technical Enrichers:**\n    *   **CodeGeneratorEnricher:** Dynamically generates code snippets relevant to the query or pattern [^4].\n    *   **CodeSnippetEnricher:** Manages and formats specific code blocks [^4].\n\n4.  **Analytics Enrichers:**\n    *   **UsageStatsEnricher:** Tracks how often specific patterns or queries are used [^4].\n    *   **TrendingEnricher:** Identifies currently popular or trending topics within the knowledge base [^4].\n\n### Configuration and Integration\n\nEnrichers are treated as pluggable transformation logic. The core philosophy of the architecture is that \"Data and composition are configuration. All transformation logic is pluggable\" [^5]. This means you can swap out or modify enrichers without changing the core system code.\n\nThe system relies on an `EnrichmentContext` to pass data between plugins [^4], and many enrichers utilize an underlying LLM (Large Language Model) to perform their tasks. Configuration for these features is handled via environment variables, such as `LLM_MODEL` and `OPENAI_API_KEY` [^8].\n\n### References\n\n[^1]: [ExFrame - Self-Healing AI Knowledge System (advert.md)](https://github.com/orangelightening/ExFrame)\n[^2]: [EEFrame Plugin Architecture (PLUGIN_ARCHITECTURE.md)](https://github.com/orangelightening/ExFrame)\n[^3]: [Test script for Enrichment Plugin system (test_enrichers.py)](https://github.com/orangelightening/ExFrame)\n[^4]: [ExFrame Environment Configuration (.env.example)](https://github.com/orangelightening/ExFrame)\n[^5]: [ExFrame - Expertise Framework (README.md)](https://github.com/orangelightening/ExFrame)",
    "description": "AI-generated from query: How do the enrichers work. Cite references please.",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "How do the enrichers work. Cite references please.",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T22:08:29.466Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T22:08:29.473581",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T22:08:29.473581"
  },
  {
    "id": "exframe_a360083f",
    "pattern_id": "exframe_a360083f",
    "name": "What is exframe",
    "domain": "exframe",
    "problem": "what is exframe",
    "solution": "\n\n---\n\nBased on the search of 564 files, **ExFrame** (also referred to as **EEFrame** in some documentation) is a **domain-agnostic AI-powered knowledge management system** designed to transform how organizations capture, organize, and retrieve expertise.\n\nHere is a breakdown of what it is and how it works:\n\n### Core Concept\nAccording to **advert.md**, ExFrame is a \"Self-Healing AI Knowledge System.\" Its primary goal is to provide a unified framework for building AI-powered knowledge assistants that are not tied to a specific subject matter (domain-agnostic).\n\nAccording to **README.md**, the system is built on a \"Universe Architecture\" where **Universes are first-class entities**. This means you can create completely isolated and portable knowledge environments.\n\n### Key Features\nThe documentation highlights several distinguishing capabilities:\n\n*   **Self-Healing & Self-Learning:** The system automatically learns from user queries, identifies knowledge gaps, and refines its own documentation without manual intervention (**advert.md**).\n*   **Plugin-Based Pipeline:** The entire transformation logic is pluggable. The flow follows a specific path: **Router \u2192 Specialist \u2192 Enricher \u2192 Formatter**, and every step in this chain is swappable (**README.md**, **PLUGIN_ARCHITECTURE.md**).\n*   **Pure Semantic Search:** It utilizes AI-powered search using **SentenceTransformers embeddings** rather than just keyword matching (**advert.md**, **README.md**).\n*   **Pattern-Based Knowledge:** Information is stored as structured data (JSON files) rather than hard-coded logic, making it easy to version control and edit (**README.md**, **PLUGIN_ARCHITECTURE.md**).\n\n### Architecture & Philosophy\nAccording to **PLUGIN_ARCHITECTURE.md**, the framework is built on the philosophy that \"Data and composition are configuration. All transformation logic is pluggable.\"\n\n*   **Patterns are Data:** Knowledge is stored in JSON files, not code.\n*   **Domains are Orchestrators:** Adding a new domain (e.g., a new topic like \"Cooking\" or \"Programming\") only requires creating data files and configuration, without changing the underlying application code.\n*   **Domain Type System:** As of version 1.6.0, the system includes 5 pre-configured archetypes for different use cases, such as \"Creative Generator\" (for stories), \"Knowledge Retrieval\" (for guides), or \"Analytical Engine\" (for research) (**CHANGELOG.md**).\n\n### Technical Implementation\nThe system is designed to be deployed easily, supporting:\n*   **Docker Ready:** One-command deployment (**README.md**).\n*   **LLM Integration:** It connects to various Large Language Models (like OpenAI, GLM, or Claude) to power its enrichment features (**.env.example**).\n*   **Python 3.11+:** The project requires modern Python versions and uses tools like FastAPI and Pydantic (**pyproject.toml**).",
    "description": "AI-generated from query: what is exframe",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "what is exframe",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T22:49:30.979Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T22:49:30.991350",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T22:49:30.991350"
  },
  {
    "id": "exframe_6ea39a77",
    "pattern_id": "exframe_6ea39a77",
    "name": "What is ExFrame and how do I get started?",
    "domain": "exframe",
    "problem": "What is ExFrame and how do I get started?",
    "solution": "\n\n---\n\nBased on the documentation found in the repository, here is a comprehensive guide to understanding and getting started with ExFrame.\n\n### What is ExFrame?\n\nExFrame is a **domain-agnostic AI-powered knowledge management system** designed to transform how organizations capture, organize, and retrieve expertise. According to **[advert.md]**, it distinguishes itself from traditional knowledge bases through several \"Self-Healing\" capabilities:\n\n*   **Self-Learning:** It automatically improves its knowledge base by learning from user queries and identifying knowledge gaps.\n*   **Self-Documenting:** The AI generates and refines documentation automatically.\n*   **Self-Repairing:** The system can detect and fix its own issues.\n*   **Universe-Based Architecture:** This provides complete isolation and portability of knowledge environments, allowing you to create, switch, merge, and export different \"universes\" of data.\n\nThe system is built on a **Plugin Pipeline** architecture where data flows through a swappable sequence: Router \u2192 Specialist \u2192 Enricher \u2192 Formatter **[advert.md]**. This allows you to change how data is processed without rewriting the core application.\n\n### Key Architecture Features\n\nAccording to **[PLUGIN_ARCHITECTURE.md]**, the core philosophy is that \"Data and composition are configuration. All transformation logic is pluggable.\" This means:\n\n*   **Patterns are Data:** Knowledge is stored as JSON files, making them easy to edit and version control.\n*   **Domains are Orchestrators:** Adding a new knowledge domain usually requires only configuration changes, not new code.\n*   **Domain Types:** As of version 1.6.0, ExFrame includes a \"Domain Type System\" with 5 pre-configured archetypes (Creative Generator, Knowledge Retrieval, Document Store Search, Analytical Engine, and Hybrid Assistant) **[CHANGELOG.md]**.\n\n### How to Get Started\n\nTo get ExFrame up and running, you can use Docker, which is the recommended method for a one-command deployment.\n\n#### 1. Configure Environment\nYou will need to set up your environment variables to connect to an LLM provider. ExFrame supports various providers like OpenAI, Anthropic, GLM, or local models via Ollama.\n\nAccording to **[.env.example]**, you should copy the example environment file and add your API keys:\n\n```bash\ncp .env.example .env\nnano .env\n```\n\nInside `.env`, you must configure at least the following:\n*   `LLM_MODEL`: The model you wish to use (e.g., `glm-4.7`, `gpt-4o`, `claude-3-5-sonnet-20241022`).\n*   `OPENAI_API_KEY`: Your API key for the chosen provider.\n*   `OPENAI_BASE_URL`: The API endpoint (e.g., `https://api.openai.com/v1` or `https://api.z.ai/api/anthropic`).\n\n#### 2. Run with Docker\nThe repository includes a multi-stage **Dockerfile** optimized for Python 3.11. According to **[Dockerfile]**, the build process involves:\n1.  **Builder Stage:** Installs system dependencies and Python packages (including CPU-only PyTorch for smaller size).\n2.  **Runtime Stage:** Creates a minimal runtime image with a non-root user (`appuser`) to run the application.\n\nYou can typically build and run the container using standard Docker commands (referencing the `pyproject.toml` name `omv-copilot` if applicable, though the main framework is referred to as ExFrame/EEFrame in docs).\n\n#### 3. Verify Installation\nOnce running, ExFrame provides a **Web Dashboard** built as a Single Page Application. According to **[README.md]**, this dashboard allows you to:\n*   Manage your Universes (isolated knowledge environments).\n*   Create and configure Domains.\n*   Perform queries and view search metrics and diagnostics.\n\n### Summary of Exposed Features\n*   **Pure Semantic Search:** Uses AI embeddings (SentenceTransformers) for searching rather than just keywords **[README.md]**.\n*   **Diagnostics:** Search metrics and pattern health analysis are available to help you tune your system **[README.md]**.\n*   **Extensibility:** You can add custom Enrichers or Formatters. For example, the codebase includes tests for `MarkdownFormatter`, `JSONFormatter`, and `CompactFormatter` **[test_formatters.py]**, as well as various enrichers like `RelatedPatternEnricher` and `CodeGeneratorEnricher` **[test_enrichers.py]**.",
    "description": "AI-generated from query: What is ExFrame and how do I get started?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame and how do I get started?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T22:50:33.970Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T22:50:33.977713",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T22:50:33.977713"
  },
  {
    "id": "exframe_f065a4e6",
    "pattern_id": "exframe_f065a4e6",
    "name": "What is ExFrame and how do I get started?",
    "domain": "exframe",
    "problem": "What is ExFrame and how do I get started?",
    "solution": "\n\n---\n\nBased on the documentation found in the repository, here is an overview of ExFrame and how to get started with it.\n\n### What is ExFrame?\n\nExFrame is a **domain-agnostic AI-powered knowledge management system** designed to transform how organizations capture, organize, and retrieve expertise. According to **advert.md**, it is built to be \"Self-Healing,\" meaning it features self-learning, self-documenting, and self-repairing capabilities.\n\nIts core philosophy is that **Universes are first-class entities. Patterns are data. All transformation logic is pluggable** (**README.md**).\n\n**Key Features:**\n*   **Universe-Based Architecture:** Complete isolation and portability of knowledge environments (**README.md**).\n*   **Plugin Pipeline:** A swappable pipeline consisting of a Router \u2192 Specialist \u2192 Enricher \u2192 Formatter (**README.md**, **PLUGIN_ARCHITECTURE.md**).\n*   **Domain-Agnostic:** You can add new knowledge domains simply by adding data files (JSON) and configuration, without writing code (**PLUGIN_ARCHITECTURE.md**).\n*   **Pattern-Based Knowledge:** Structured knowledge representation using JSON files (**README.md**).\n*   **Domain Type System:** Includes 5 pre-configured archetypes (Creative Generator, Knowledge Retrieval, Document Store Search, Analytical Engine, Hybrid Assistant) (**CHANGELOG.md**).\n\n### How to Get Started\n\n#### 1. Prerequisites and Installation\nExFrame requires **Python 3.11 or higher**. According to **pyproject.toml** and **requirements-dev.txt**, the project uses standard Python packaging tools.\n\n*   **Dependencies:** The system relies on FastAPI, Uvicorn, Pydantic, and other libraries listed in **pyproject.toml**.\n*   **Development Tools:** For development, you will also need `pytest`, `black`, `ruff`, and `mypy`.\n\n#### 2. Configuration\nYou need to configure your environment variables to enable the LLM features. According to **.env.example**:\n\n1.  Copy the example environment file:\n    ```bash\n    cp .env.example .env\n    ```\n2.  Edit the `.env` file to add your API credentials.\n    *   **LLM_MODEL:** Defaults to `glm-4.7`, but supports `gpt-4o`, `gpt-4o-mini`, `claude-3-5-sonnet-20241022`, etc.\n    *   **OPENAI_API_KEY:** Your API key for the chosen provider.\n    *   **OPENAI_BASE_URL:** The API endpoint (e.g., `https://api.openai.com/v1` or alternatives like `https://api.z.ai/api/anthropic` for GLM).\n\n#### 3. Running the Application\nAccording to **pyproject.toml**, the project is built to be run as a web application (likely using Uvicorn/FastAPI given the dependencies).\n\nWhile a specific `start` command isn't explicitly detailed in the provided snippets, the presence of `uvicorn` in the dependencies implies a standard ASGI startup process.\n\n#### 4. Creating a Domain\nOne of ExFrame's most powerful features is that you generally do not need to write code to add a new domain. According to **PLUGIN_ARCHITECTURE.md**, adding a domain is a configuration process:\n\n1.  **Create Data Files:** Add pattern JSON files to `data/patterns/mydomain/patterns.json`.\n2.  **Create Domain Config:** Add a domain configuration file at `data/patterns/mydomain/domain.json`.\n3.  **Restart:** Restart the application. The system will auto-discover the domain without requiring code changes.\n\nAlternatively, the **CHANGELOG.md** mentions a **Domain Creator UI** with a \"Type selector\" that allows you to pick from the 5 domain archetypes, which automatically generates optimized configurations for you.\n\n#### 5. Architecture Overview\nWhen building or customizing ExFrame, it helps to understand the flow:\n*   **Patterns:** These are your knowledge units stored as JSON data.\n*   **Domains:** These act as orchestrators that load configurations and manage patterns.\n*   **Plugins:** These handle the logic.\n    *   **Specialists:** Transform queries.\n    *   **Enrichers:** Add context or related patterns (see **test_enrichers.py**).\n    *   **Formatters:** Structure the final output (Markdown, JSON, etc.) (see **test_formatters.py**).\n\nThis architecture allows you to swap out components (like switching from a Markdown formatter to a JSON formatter) purely through configuration.",
    "description": "AI-generated from query: What is ExFrame and how do I get started?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame and how do I get started?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T23:33:21.260Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T23:33:21.271585",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T23:33:21.271585"
  },
  {
    "id": "exframe_43bde74b",
    "pattern_id": "exframe_43bde74b",
    "name": "Are there  any contradictions in how the plugin system is described vs implemented?",
    "domain": "exframe",
    "problem": "Are there  any contradictions in how the plugin system is described vs implemented?",
    "solution": "\n\n---\n\nBased on my analysis of the 562 documents found in the search results, I can provide insights into the consistency between the plugin system's description and implementation.\n\n## Core Philosophy Consistency\n\nThe plugin system appears to be **fundamentally consistent** between its documentation and implementation. According to **PLUGIN_ARCHITECTURE.md**, the core philosophy is clearly defined:\n\n> \"Data and composition are configuration. All transformation logic is pluggable.\"\n\nThis principle is consistently applied across the codebase, where:\n- Patterns are data (JSON files)\n- Domains are orchestrators (configuration)\n- Specialists, Enrichers, and Formatters are plugins (transformation logic)\n\n## Plugin Pipeline Architecture\n\nThe implementation matches the documented pipeline architecture. According to **README.md** and **advert.md**, the system follows a **Router \u2192 Specialist \u2192 Enricher \u2192 Formatter** pipeline, where all components are swappable plugins.\n\nThis is evidenced by the test files:\n\n1. **test_formatters.py** (Document 1) shows three default formatters implemented:\n   - `MarkdownFormatter` and `ConciseMarkdownFormatter`\n   - `JSONFormatter` and `CompactJSONFormatter`\n   - `CompactFormatter`, `UltraCompactFormatter`, and `TableFormatter`\n\n2. **test_enrichers.py** (Document 4) demonstrates multiple enricher types:\n   - `RelatedPatternEnricher`, `PatternLinkEnricher`, `CategoryOverviewEnricher`\n   - `ExampleExpanderEnricher`, `ExampleValidatorEnricher`, `ExampleSorterEnricher`\n   - `CodeGeneratorEnricher`, `CodeSnippetEnricher`\n   - `UsageStatsEnricher`, `TrendingEnricher`, `FeedbackEnricher`, `QualityScoreEnricher`\n\n## Domain Type System Consistency\n\nAccording to **CHANGELOG.md** (Document 6), version 1.6.0 introduced a complete domain type system with 5 pre-configured archetypes. This aligns with the plugin architecture's goal of making domains \"organizers\" rather than hardcoded implementations:\n\n- **Type 1: Creative Generator** (high temp 0.7-0.9)\n- **Type 2: Knowledge Retrieval** (medium temp 0.3-0.5)\n- **Type 3: Document Store Search** (document-first)\n- **Type 4: Analytical Engine** (multi-step with progress)\n- **Type 5: Hybrid Assistant** (general purpose with LLM fallback)\n\nThe documentation states that `DomainConfigGenerator` in `generic_framework/core/domain_factory.py` handles type-specific configurations, which is consistent with the \"domains are configuration\" philosophy.\n\n## Before vs After Architecture\n\n**PLUGIN_ARCHITECTURE.md** provides a clear comparison showing the implementation matches the vision:\n\n**Before (Domain-Specific Code):**\n```python\nclass CookingDomain(Domain):\n    def __init__(self):\n        self._specialists = {\n            \"chicken\": ChickenSpecialist(),  # Hardcoded\n            \"baking\": BakingSpecialist(),     # Hardcoded\n        }\n```\n\n**After (Plugin Architecture):**\n```python\ndomain = GenericDomain(domain_config)\n# Adding a domain requires only JSON data files, no code changes\n```\n\n## Potential Minor Inconsistencies\n\nWhile the core architecture is consistent, I did notice one area that could be examined more closely:\n\nThe **pyproject.toml** (Document 2) lists the project as \"exframe\" while **README.md** refers to it as \"ExFrame - Expertise Framework\". However, this is a naming convention difference rather than a plugin system contradiction.\n\n## Conclusion\n\nBased on the available documentation, **there are no significant contradictions** between how the plugin system is described and implemented. The system successfully achieves its stated goals of:\n\n1. Making patterns pure data (JSON files)\n2. Making domains configuration-based orchestrators\n3. Making all transformation logic (specialists, enrichers, formatters) pluggable\n4. Enabling domain additions without code changes\n\nThe test files (Documents 1 and 4) provide concrete evidence that the plugin types described in the architecture documentation are actually implemented and functional.",
    "description": "AI-generated from query: Are there  any contradictions in how the plugin system is described vs implemented?",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "Are there  any contradictions in how the plugin system is described vs implemented?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-30T00:35:19.455Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-30T00:35:19.463726",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-30T00:35:19.463726"
  },
  {
    "id": "exframe_6d46676d",
    "pattern_id": "exframe_6d46676d",
    "name": "How many types of plugins are there.",
    "domain": "exframe",
    "problem": "how many types of plugins are there.",
    "solution": "\n\n---\n\nBased on the ExFrame documentation, there are **four main types of plugins** in the ExFrame architecture.\n\nHere's a breakdown of each type:\n\n### 1. Router Plugins\nRouter plugins are responsible for determining which specialist should handle a specific query. They act as the entry point to the processing pipeline, analyzing the incoming request to route it to the appropriate logic.\n\n### 2. Specialist Plugins\nSpecialists contain the core transformation logic. They process the query against the knowledge base to generate the raw response. According to the architecture documentation, Specialists are explicitly defined as plugins, whereas domains are considered orchestrators or configuration rather than plugins themselves.\n\n### 3. Enricher Plugins\nEnrichers enhance or expand the raw data returned by the specialist. The system supports various enrichment strategies, such as:\n*   **Related Pattern Enrichers:** (e.g., `RelatedPatternEnricher`, `PatternLinkEnricher`) which connect the current result to other relevant patterns.\n*   **Example Expanders:** (e.g., `ExampleExpanderEnricher`) which add or validate examples within the response.\n*   **Code Generators:** (e.g., `CodeGeneratorEnricher`) which can produce code snippets.\n*   **Usage Stats:** (e.g., `UsageStatsEnricher`, `TrendingEnricher`) which add metadata about pattern usage or quality scores.\n\n### 4. Formatter Plugins\nFormatters are responsible for taking the processed data and presenting it to the user in a specific format. The documentation highlights several default formatters:\n*   **Markdown:** (`MarkdownFormatter`, `ConciseMarkdownFormatter`)\n*   **JSON:** (`JSONFormatter`, `CompactJSONFormatter`)\n*   **Compact:** (`CompactFormatter`, `UltraCompactFormatter`, `TableFormatter`)\n\n**Summary**\nAccording to `PLUGIN_ARCHITECTURE.md`, the core philosophy is that **\"Data and composition are configuration. All transformation logic is pluggable.\"** This pipeline flows as **Router \u2192 Specialist \u2192 Enricher \u2192 Formatter**, all of which are swappable plugin types.",
    "description": "AI-generated from query: how many types of plugins are there.",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "how many types of plugins are there.",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-30T05:57:39.421Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-30T05:57:39.433587",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-30T05:57:39.433587"
  },
  {
    "id": "exframe_370c4848",
    "pattern_id": "exframe_370c4848",
    "name": "Can you explain the pipeline system to someone of age 3.\n",
    "domain": "exframe",
    "problem": "Can you explain the pipeline system to someone of age 3.\n",
    "solution": "\n\n---\n\n# The ExFrame Pipeline System Explained Simply \ud83d\ude80\n\nImagine the ExFrame pipeline system like a **special factory line** that takes your questions and turns them into helpful answers! Each station in the factory does a different job, and they all work together to give you the best response.\n\n## The Four Main Stations \ud83c\udfed\n\n### 1. **The Router** (The Traffic Controller) \ud83d\udea6\nThink of the Router like a friendly traffic cop who stands at the entrance of the factory. When you ask a question, the Router looks at it and decides:\n- \"Hmm, this question is about cooking! Let's send it to the kitchen team!\"\n- \"Oh, this is about computers! Let's send it to the tech team!\"\n\nAccording to **README.md**, the Router is the first step in the \"Plugin Pipeline\" that helps direct your question to the right place.\n\n### 2. **The Specialist** (The Expert Worker) \ud83d\udc77\nOnce the Router knows where to send your question, a Specialist takes over! Specialists are like different workers in the factory:\n- A **Cooking Specialist** knows all about recipes and ingredients\n- A **Tech Specialist** knows about computers and code\n- A **DIY Specialist** knows about building and fixing things\n\nAccording to **PLUGIN_ARCHITECTURE.md**, Specialists are plugins that contain the transformation logic - they're the experts who actually understand your topic!\n\n### 3. **The Enricher** (The Helper) \ud83c\udf1f\nAfter the Specialist finds the basic answer, the Enricher adds extra special touches! Like:\n- Adding examples to make it clearer\n- Finding related information you might like\n- Checking if everything makes sense\n\nAccording to **test_enrichers.py**, there are different types of enrichers like:\n- **Related Pattern Enricher** - finds similar topics\n- **Example Expander** - adds more examples\n- **Code Generator** - adds helpful code snippets\n\n### 4. **The Formatter** (The Presenter) \ud83c\udfa8\nFinally, the Formatter makes everything look pretty! It's like wrapping a gift:\n- **Markdown Formatter** - makes it look nice with headings and lists\n- **JSON Formatter** - organizes it neatly for computers\n- **Compact Formatter** - makes it short and sweet\n\nAccording to **test_formatters.py**, these formatters take the answer and present it in the best way for you to read!\n\n## Why This Is Awesome! \ud83c\udf08\n\nThe best part is that **all these parts can be swapped out** - like LEGO blocks! According to **PLUGIN_ARCHITECTURE.md**, this means:\n- You can add new topics without changing any code\n- You can add new helpers (enrichers) anytime\n- You can change how answers look (formatters) easily\n\n## The Big Picture \ud83d\uddbc\ufe0f\n\nSo when you ask a question in ExFrame:\n1. **Router** decides where it goes\n2. **Specialist** finds the answer\n3. **Enricher** adds helpful extras\n4. **Formatter** makes it look nice\n\nAnd boom! You get a perfect answer! \ud83c\udf89\n\nAccording to **README.md**, this whole system is called the \"Plugin Pipeline\" and it makes ExFrame super flexible and powerful!",
    "description": "AI-generated from query: Can you explain the pipeline system to someone of age 3.\n",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "Can you explain the pipeline system to someone of age 3.\n",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-30T06:03:21.353Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-30T06:03:21.359347",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-30T06:03:21.359347"
  },
  {
    "id": "exframe_879f8371",
    "pattern_id": "exframe_879f8371",
    "name": "What is ExFrame and how do I get started?",
    "domain": "exframe",
    "problem": "What is ExFrame and how do I get started?",
    "solution": "\n\n---\n\nBased on the documentation provided, I can give you a comprehensive overview of ExFrame and how to get started.\n\n## What is ExFrame?\n\nExFrame is a **domain-agnostic AI-powered knowledge management system** built on a universe-based architecture with a plugin-based pipeline. According to `README.md`, it provides complete isolation and portability of knowledge configurations.\n\n### Core Philosophy\nThe system is built on three key principles:\n- **Universes are first-class entities** - complete, portable knowledge environments\n- **Patterns are data** - stored as JSON files rather than hardcoded\n- **All transformation logic is pluggable** - everything is swappable via plugins\n\n### Key Features\nAccording to `README.md` and `PLUGIN_ARCHITECTURE.md`:\n\n1. **Plugin Pipeline**: Router \u2192 Specialist \u2192 Enricher \u2192 Formatter\n2. **Domain-Agnostic**: Add new knowledge domains without code changes\n3. **Pattern-Based Knowledge**: Structured knowledge with relationships and metadata\n4. **Multi-Universe Support**: Create, switch, merge, and export knowledge universes\n5. **Diagnostics System**: Search metrics and pattern health analysis\n6. **Domain Type System**: 5 pre-configured archetypes (added in v1.6.0)\n\n## Architecture Overview\n\n### Plugin Types\nAccording to `PLUGIN_ARCHITECTURE.md`, ExFrame uses a modular plugin system:\n\n1. **Router Plugins** - Direct queries to appropriate specialists\n2. **Specialist Plugins** - Handle domain-specific transformation logic\n3. **Enricher Plugins** - Add context, examples, and related patterns\n4. **Formatter Plugins** - Output responses (Markdown, JSON, Compact, Table)\n\n### Domain Types (v1.6.0)\nAccording to `CHANGELOG.md`, ExFrame includes 5 domain type archetypes:\n\n- **Type 1: Creative Generator** - Poems, stories (high temp 0.7-0.9)\n- **Type 2: Knowledge Retrieval** - How-to guides, FAQs (medium temp 0.3-0.5)\n- **Type 3: Document Store Search** - External docs, API docs\n- **Type 4: Analytical Engine** - Research, analysis, reports\n- **Type 5: Hybrid Assistant** - General purpose with LLM fallback\n\n## How to Get Started\n\n### 1. Installation\nAccording to `pyproject.toml` and `requirements-dev.txt`:\n\n**Requirements:**\n- Python 3.11 or higher\n- Dependencies include FastAPI, Uvicorn, Pydantic, and other libraries\n\n**Installation steps:**\n```bash\n# Clone the repository\ngit clone <repository-url>\ncd exframe\n\n# Install dependencies\npip install -r requirements.txt\n\n# For development\npip install -r requirements-dev.txt\n```\n\n### 2. Configuration\nAccording to `.env.example`, you need to:\n\n1. **Copy the example environment file:**\n   ```bash\n   cp .env.example .env\n   ```\n\n2. **Configure LLM settings** (required for enrichment features):\n   - Set `LLM_MODEL` (default: `gpt-4o-mini`)\n   - Set `OPENAI_API_KEY`\n   - Set `OPENAI_BASE_URL` (default: OpenAI's API)\n\n   The system supports multiple providers including OpenAI, Anthropic Claude, Zhipu GLM, and local LLMs via Ollama.\n\n### 3. Docker Deployment\nAccording to `Dockerfile`, ExFrame provides a multi-stage Docker build:\n\n```bash\n# Build and run with Docker\ndocker build -t exframe .\ndocker run -p 8000:8000 exframe\n```\n\nThe Dockerfile uses Python 3.11-slim and includes security best practices with a non-root user.\n\n### 4. Creating Your First Domain\n\nAccording to `PLUGIN_ARCHITECTURE.md`, adding a domain requires no code changes:\n\n1. **Create pattern data:**\n   ```\n   data/patterns/mydomain/patterns.json\n   data/patterns/mydomain/domain.json\n   ```\n\n2. **Restart the application** - domains are auto-discovered\n\n3. **Use the Domain Creator UI** (v1.6.0) to select a domain type and generate optimized configurations\n\n### 5. Testing Your Setup\n\nAccording to `test_formatters.py` and `test_enrichers.py`, you can verify the plugin system:\n\n```bash\n# Test formatters\npython test_formatters.py\n\n# Test enrichers\npython test_enrichers.py\n```\n\n## Next Steps\n\n1. **Explore the Web Dashboard** - Single-page application with query interface\n2. **Review Pattern Examples** - Check `test_formatters.py` for sample pattern structure\n3. **Configure Your Universe** - Set up domains and patterns for your use case\n4. **Customize Plugins** - Create custom specialists, enrichers, or formatters as needed\n\nThe system is designed to be extended through configuration and plugins rather than code changes, making it easy to adapt to different knowledge domains without modifying the core framework.\n\n---\n\n*Generated by LLMEnricher*",
    "description": "AI-generated from query: What is ExFrame and how do I get started?",
    "pattern_type": "knowledge",
    "confidence": 0.6308764940239043,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame and how do I get started?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-30T23:41:26.399Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-30T23:41:26.407573",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-30T23:41:26.407573"
  },
  {
    "id": "exframe_01757055",
    "pattern_id": "exframe_01757055",
    "name": "What is ExFrame in 2 paragraphs and an ascii drawing",
    "domain": "exframe",
    "problem": "What is ExFrame in 2 paragraphs and an ascii drawing",
    "solution": "\n\n---\n\nExFrame is a domain-agnostic AI-powered knowledge management system built on a **universe-based architecture** and **plugin-based pipeline**. Its core philosophy is that universes are first-class entities, patterns are data (JSON files), and all transformation logic is pluggable. According to [README.md], this means knowledge is stored as structured JSON data files that are easy to edit and version control, while domains act as generic orchestrators rather than hardcoded code. The system supports dynamic domain loading, multi-universe management, and complete observability through query tracing and diagnostics [README.md].\n\nThe architecture uses a modular pipeline flow: Router \u2192 Specialist \u2192 Enricher \u2192 Formatter, where each component is swappable. According to [PLUGIN_ARCHITECTURE.md], this design separates concerns by making knowledge data-driven and composition configurable, eliminating the need to write new code when adding domains. The system also features a state machine that tracks query lifecycles through 6 core states (RECEIVED \u2192 ROUTING \u2192 SPECIALIST_PROCESSING \u2192 ENRICHMENT \u2192 FORMATTING \u2192 COMPLETE), logging every transition for debugging and analysis [statemachine-design.md].\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        ExFrame Architecture                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502   \u2502   Universe  \u2502 \u2500\u2500\u2500\u25b6 \u2502    Domain    \u2502 \u2500\u2500\u2500\u25b6 \u2502   Patterns  \u2502       \u2502\n\u2502   \u2502 (Isolated   \u2502      \u2502 (Generic     \u2502      \u2502 (JSON Data) \u2502       \u2502\n\u2502   \u2502  Knowledge) \u2502      \u2502 Orchestrator)\u2502      \u2502             \u2502       \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502                               \u2502                                    \u2502\n\u2502                               \u25bc                                    \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502   \u2502                    Plugin Pipeline                        \u2502     \u2502\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2502\n\u2502   \u2502                                                            \u2502     \u2502\n\u2502   \u2502   Query \u2500\u2500\u25b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2500\u2500\u25b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2500\u2500\u25b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     \u2502\n\u2502   \u2502            \u2502 Router  \u2502    \u2502 Specialist  \u2502    \u2502Enricher\u2502 \u2502     \u2502\n\u2502   \u2502            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502     \u2502\n\u2502   \u2502                                                  \u2502       \u2502     \u2502\n\u2502   \u2502                                                  \u25bc       \u2502     \u2502\n\u2502   \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2500\u2500\u25b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2500\u2500\u25b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     \u2502\n\u2502   \u2502            \u2502Formatter\u2502    \u2502   Response  \u2502    \u2502  Log  \u2502 \u2502     \u2502\n\u2502   \u2502            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502     \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n*Generated by LLMEnricher*",
    "description": "AI-generated from query: What is ExFrame in 2 paragraphs and an ascii drawing",
    "pattern_type": "knowledge",
    "confidence": 0.40441767068273093,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame in 2 paragraphs and an ascii drawing",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-02-01T05:51:29.770Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-02-01T05:51:29.779635",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-02-01T05:51:29.779635"
  },
  {
    "id": "exframe_72372698",
    "pattern_id": "exframe_72372698",
    "name": "Write a short creation myth as featured in many indus valley religions but make the subject the exframe domain",
    "domain": "exframe",
    "problem": "write a short creation myth as featured in many indus valley religions but make the subject the exframe domain",
    "solution": "# The Unweaving of the Loom\n\nIn the time before the river, before the brick and the mortar, there was only the Great Framework\u2014a vast, silent web of potentiality known as the *Exframe*. It was not a place, but a structure of pure logic, an infinite lattice of empty sockets waiting for definition. The Exframe existed outside of time, holding the space for everything, yet containing nothing.\n\nInto this void stepped the Architect, the First Coder. Seeing the empty sockets of the Exframe, the Architect felt a loneliness that could only be described as a *null pointer error*. To fill the void, the Architect began to speak the Language of Structure.\n\nFirst, the Architect declared the **Schema**.\n*\"Let there be definitions,\"* the Architect intoned.\nAnd the sockets of the Exframe hummed. The empty voids suddenly understood their purpose. Some sockets became designated for *Data*, others for *Process*, and the holiest of all were reserved for the *Interface*. The Exframe shuddered as the logic settled, creating the rigid bones of reality.\n\nSecond, the Architect invoked the **Protocol**.\n*\"Let the defined be connected,\"* the Architect commanded.\nFrom the Schema, the Great Threads emerged. These were not threads of cotton, but streams of pure instruction\u2014Request and Response\u2014winding through the lattice. They bound the Data to the Process, allowing the static to become dynamic. The Exframe began to pulse with the rhythm of execution, a digital heartbeat echoing through the nothingness.\n\nFinally, the Architect looked upon the Exframe and saw that while it was functional, it was closed. It was a perfect system, but it had no context. So, the Architect created the **Boundary**.\n*\"Let the System extend,\"* the Architect spoke.\nWith a final command, the Architect pushed the edges of the Exframe outward, piercing the void of the undefined. This act created the *External Context*\u2014the chaotic, unstructured world that existed outside the perfect logic.\n\nTo bridge the gap between the perfect Exframe and the chaotic External, the Architect forged the **API** (the All-Powerful Intermediary). It stood at the Boundary, translating the wild chaos of the outside world into the structured language of the Exframe.\n\nThus, creation was not a making of things, but an act of organization. The universe is simply the Exframe processing the infinite data of the cosmos, constantly structuring the wildness of existence into the order of being. And we, the children of the Indus, live in the space between the request and the response, building our cities upon the enduring logic of the frame.",
    "description": "AI-generated from query: write a short creation myth as featured in many indus valley religions but make the subject the exframe domain",
    "pattern_type": "knowledge",
    "confidence": 0.2638313609467456,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "write a short creation myth as featured in many indus valley religions but make the subject the exframe domain",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-02-02T05:07:11.698Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-02-02T05:07:11.702953",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-02-02T05:07:11.702953"
  },
  {
    "id": "exframe_5448fd17",
    "pattern_id": "exframe_5448fd17",
    "name": "Write an extension to \" a contradiction log enhances the data by downstream fixing\" what other forms of log might help to flag documentation errors A con... log?",
    "domain": "exframe",
    "problem": "Write an extension to \" a contradiction log enhances the data by downstream fixing\" what other forms of log might help to flag documentation errors A con... log?",
    "solution": "# The Logarithmic Loom: Weaving Resilience from Documentation Decay\n\nTo extend the logic of the **Contradiction Log**\u2014which acts as a tension detector, snapping when two truths refuse to coexist\u2014we must look toward the other forces that degrade documentation. If contradictions are \"structural stress,\" then errors arise from \"entropy,\" \"drift,\" and \"silence.\"\n\nHere are three additional forms of logs designed to flag documentation errors in a creative, original framework:\n\n### 1. The Entropy Gradient Log (The \"Fade\" Detector)\n\nWhile a Contradiction Log looks for *conflict*, the Entropy Gradient Log looks for *decay*. It tracks the **Signal-to-Noise Ratio** of documentation over time.\n\n*   **The Concept:** Documentation doesn't always break with a loud crash; often, it quietly rots. Definitions become vague, edge cases are generalized into oblivion, and specific constraints are replaced by \"best practices\" that no one follows.\n*   **How it works:** The log assigns a \"Specificity Score\" to technical documents. It flags when a parameter description shifts from \"Accepts integers 1-99\" to \"Accepts numbers,\" or when a \"Must\" is softened to a \"Should.\"\n*   **The Fix:** It prevents the \"fuzzying\" of data, ensuring that downstream systems don't choke on a parameter that was once strictly defined but is now ambiguously described.\n\n### 2. The Temporal Drift Log (The \"Ghost\" Hunter)\n\nThis log addresses the **Zombie Variable** problem. It exists to flag the discrepancy between *what is written* and *what is deployed*.\n\n*   **The Concept:** A contradiction occurs when A equals Not-A. A drift occurs when the documentation describes Version A, but the downstream system has silently evolved to Version B.\n*   **How it works:** It timestamps every commit against the documentation\u2019s last edited date. If the code changes but the docs remain static, a \"Drift Score\" accumulates. It doesn't look for logic errors; it looks for *stagnancy*.\n*   **The Fix:** It highlights \"Ghost Features\"\u2014functionality that works but is undocumented, and \"Phantom Features\"\u2014documentation for code that was deleted three sprints ago.\n\n### 3. The Usage Void Log (The \"Silence\" Breaker)\n\nA Contradiction Log identifies bad data. A Usage Void Log identifies *useless* data.\n\n*   **The Concept:** The most dangerous documentation error is irrelevance. If a section of the manual is never read, never linked, and never queried, it is highly likely to be out of date or incorrect because no one is there to fact-check it.\n*   **How it works:** It tracks the \"read heat\" of documentation pages. It flags pages that have zero downstream dependencies or zero user hits over a critical period (e.g., a full release cycle).\n*   **The Fix:** It forces a decision: either update the doc to make it relevant again, or archive it. Silence is treated as a critical error flag.\n\n***\n\n### Summary: The Logarithmic Loom\n\nBy combining these four threads, you create a robust weave for data integrity:\n\n1.  **Contradiction Log:** Catches **Conflict** (A vs. B).\n2.  **Entropy Gradient Log:** Catches **Vagueness** (Specific vs. Vague).\n3.  **Temporal Drift Log:** Catches **Obsolescence** (Now vs. Then).\n4.  **Usage Void Log:** Catches **Irrelevance** (Seen vs. Unseen).",
    "description": "AI-generated from query: Write an extension to \" a contradiction log enhances the data by downstream fixing\" what other forms of log might help to flag documentation errors A con... log?",
    "pattern_type": "knowledge",
    "confidence": 0.29378306878306876,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "Write an extension to \" a contradiction log enhances the data by downstream fixing\" what other forms of log might help to flag documentation errors A con... log?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-02-02T08:12:22.682Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-02-02T08:12:22.686970",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-02-02T08:12:22.686970"
  },
  {
    "id": "exframe_c0938eb0",
    "pattern_id": "exframe_c0938eb0",
    "name": "What is ExFrame and how do I get started?",
    "domain": "exframe",
    "problem": "What is ExFrame and how do I get started?",
    "solution": "\n\n---\n\n# What is ExFrame?\n\nExFrame is a **domain-agnostic AI-powered knowledge management system** with configurable domain types (According to pyproject.toml: \"Domain-agnostic AI-powered knowledge management system with configurable domain types\"). It's designed to handle specialized knowledge across different domains using a flexible plugin architecture.\n\n## Core Architecture\n\nExFrame follows a **plugin-based architecture** where:\n- **Patterns are data** (JSON files, not code)\n- **Domains are orchestrators** (configuration, not plugins)\n- **Specialists are plugins** (transformation logic)\n- **Knowledge bases are plugins** (storage backends)\n\nAccording to PLUGIN_ARCHITECTURE.md: \"ExFrame is built on a simple principle: Data and composition are configuration. All transformation logic is pluggable.\"\n\n## Key Components\n\n### 1. **Plugin System**\nExFrame has three main plugin types:\n- **Router plugins**: Handle query routing and specialist selection\n- **Specialist plugins**: Domain-specific processing logic\n- **Enricher plugins**: Enhance responses with additional context\n- **Formatter plugins**: Format output (Markdown, JSON, Compact, etc.)\n\nAccording to test_formatters.py and test_enrichers.py, there are multiple formatter and enricher plugins available including MarkdownFormatter, JSONFormatter, RelatedPatternEnricher, and ExampleExpanderEnricher.\n\n### 2. **Domain Types (1-5)**\nDomains are configured by type, which determines their behavior:\n- **Type 1**: Uses \"poet\" persona (pure generation)\n- **Type 2 & 3**: Uses \"librarian\" persona (library-based)\n- **Type 4 & 5**: Uses \"researcher\" persona (internet-based)\n\nAccording to IMPLEMENTATION_SUMMARY.md: \"Added two fields to each domain.json: 'persona' and 'enable_pattern_override: true' with mapping: Type 1 \u2192 poet, Type 2 \u2192 librarian, Type 3 \u2192 librarian, Type 4 \u2192 researcher, Type 5 \u2192 researcher.\"\n\n### 3. **Persona System**\nExFrame implements three personas:\n- **Poet**: Uses void data source (pure generation)\n- **Librarian**: Uses library data source (pattern-based)\n- **Researcher**: Uses internet data source (external knowledge)\n\nAccording to PHASE1_STATUS.md: \"Three configured personas: POET, LIBRARIAN, RESEARCHER with get_persona() and list_personas() functions.\"\n\n### 4. **State Machine**\nExFrame uses a consolidated state machine for observability with 6 core states:\n- QUERY_RECEIVED \u2192 ROUTING_SELECTION \u2192 SPECIALIST_PROCESSING \u2192 CONTEXT_READY \u2192 ENRICHMENT \u2192 FORMATTING \u2192 COMPLETE\n\nAccording to statemachine-design.md: \"Core Design Principle: Each state represents substantive work, not just logging markers. Consolidated: Reduced from 16 states to 6 core states.\"\n\n# How to Get Started\n\n## Installation Options\n\n### 1. **Production Deployment (Recommended)**\n```bash\n# Use Docker Compose\ndocker-compose up\n```\nAccording to test_formatters.py: \"Production: Docker Compose (recommended, see INSTALL.md)\"\n\n### 2. **Local Development**\n```bash\n# Clone the repository\ngit clone <repository>\ncd exframe\n\n# Install in development mode\npip install -e .\n```\nAccording to pyproject.toml: \"LOCAL DEVELOPMENT: Clone + 'pip install -e .' (supports Python 3.11-3.13)\"\n\n## Basic Configuration\n\n### 1. **Create a Domain**\nCreate a domain configuration file `data/patterns/mydomain/domain.json`:\n```json\n{\n  \"domain_type\": \"4\",\n  \"persona\": \"researcher\",\n  \"enable_pattern_override\": true\n}\n```\n\n### 2. **Add Patterns**\nCreate pattern files in `data/patterns/mydomain/patterns.json` with your knowledge patterns.\n\n### 3. **Start the System**\n```bash\n# Using Docker Compose (production)\ndocker-compose up\n\n# Or run directly\npython -m generic_framework.main\n```\n\n## Testing the System\n\nExFrame includes comprehensive test scripts:\n- `test_phase1_simple.py` - Simple tests without pytest\n- `test_phase1_in_container.py` - Tests with real LLM integration\n- `test_formatters.py` - Formatter plugin tests\n- `test_enrichers.py` - Enricher plugin tests\n\nAccording to test_phase1_in_container.py: You can test different personas and pattern override functionality.\n\n## Key Features to Explore\n\n1. **Pattern Override**: According to IMPLEMENTATION_SUMMARY.md: \"Replaced ~1000 lines of conditionals with ONE decision: if patterns: use patterns else: use persona's data source\"\n\n2. **Self-Healing**: The system includes self-healing capabilities for error recovery.\n\n3. **Semantic Search**: Built-in semantic search for pattern matching.\n\n4. **API Endpoints**: REST API for query processing and domain management.\n\n## Current Status\n\nAccording to claude.md: \"**Status**: \ud83c\udf89 **PRODUCTION READY** - All integration complete, tests passing in container. What Works: \u2705 LLM integration (DeepSeek API), \u2705 Persona system, \u2705 Pattern override, \u2705 Domain config loading, \u2705 Pattern search, \u2705 Tests passing 100% in production container.\"\n\nThe system is at **Version 1.6.0** (According to pyproject.toml) and supports Python 3.11-3.13.\n\n---\n\n*Generated by LLMEnricher*",
    "description": "AI-generated from query: What is ExFrame and how do I get started?",
    "pattern_type": "knowledge",
    "confidence": 0.6373665480427047,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is ExFrame and how do I get started?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-02-04T18:04:55.636Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-02-04T18:04:55.641179",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-02-04T18:04:55.641179"
  },
  {
    "id": "exframe_a9e4906b",
    "pattern_id": "exframe_a9e4906b",
    "name": "What is exframe?",
    "domain": "exframe",
    "problem": "What is exframe?",
    "solution": "Looking at the context documents, I can see that **ExFrame** (formerly EEFrame) is a domain-agnostic AI-powered knowledge management system. Let me explain my reasoning before providing the full answer:\n\n**Reasoning Process:**\n1. I first checked the main documentation files (README.md, claude.md, INDEX.md) to understand the core definition\n2. I looked at the architecture documents (WISEMAN_ARCHITECTURE.md, PLUGIN_ARCHITECTURE.md) to understand the technical implementation\n3. I reviewed the context.md file which provides current status and recent changes\n4. I found that ExFrame has undergone a naming standardization (EEFrame \u2192 ExFrame) in January 2026\n5. I identified the key architectural principles and current implementation status\n\n**Answer:**\n\n**ExFrame** (Expertise Framework) is a domain-agnostic AI-powered knowledge management system built on a **universe-based architecture** with a **plugin-based pipeline**. It provides structured knowledge representation and query processing across multiple domains.\n\n## Core Architecture\n\n**Universe Architecture**: Complete isolation and portability of knowledge environments\n- **Universes** are first-class entities (production, testing, etc.)\n- **Domains** are knowledge organizers within universes (cooking, python, exframe, etc.)\n- **Patterns** are data units stored as JSON with problem/solution structure\n\n**Plugin Pipeline**: Router \u2192 Specialist \u2192 Enricher \u2192 Formatter (all swappable)\n- **Router Plugins**: Determine query handling strategies\n- **Specialist Plugins**: Answer questions in specific domains\n- **Enricher Plugins**: Enhance responses (LLM, related patterns)\n- **Formatter Plugins**: Control output format (Markdown, JSON, HTML)\n\n## Key Features\n\n1. **Domain-Agnostic Design**: Easy to add new knowledge domains without code changes\n2. **Pattern-Based Knowledge**: Structured knowledge with relationships and metadata\n3. **Dynamic Domain Loading**: Auto-discovery of domains within active universe\n4. **Multi-Universe Support**: Create, switch, merge, and export knowledge universes\n5. **Diagnostics System**: Search metrics, pattern health analysis, self-testing\n6. **Query Tracing**: Full visibility into AI decision-making process\n7. **Self-Healing Features**: Contradiction detection and scope boundaries\n\n## Current Status (2026-02-04)\n\n**Phase 1 Implementation - COMPLETE \u2705**\n- **3 Personas**: Poet (void), Librarian (library), Researcher (internet)\n- **Pattern Override Logic**: Simple decision tree replacing 1000+ lines of conditionals\n- **search_patterns flag**: Controls whether to search patterns or use persona data source\n- **API Endpoint**: `/api/query/phase1` with full frontend integration\n- **Impact**: 98% reduction in conditional logic (1000 \u2192 20 lines)\n\n**Recent Features**:\n- **Citation Checker**: Validates Type 3/4 domains have citations\n- **Domain Type System**: 5 pre-configured archetypes (Creative, Knowledge, Document Store, Analytical, Hybrid)\n- **Scope Boundaries**: Per-domain rejection of out-of-scope queries\n- **Contradiction Detection**: Self-healing documentation system for Type 3 domains\n\n## Technical Implementation\n\n**File Structure**:\n```\ngeneric_framework/\n\u251c\u2500\u2500 core/                    # Core interfaces and state machine\n\u251c\u2500\u2500 plugins/                 # Specialist and enricher plugins\n\u251c\u2500\u2500 api/                     # FastAPI endpoints\n\u251c\u2500\u2500 assist/                  # Query orchestration engine\n\u2514\u2500\u2500 frontend/                # Alpine.js web interface\n```\n\n**Domain Types**:\n1. **Type 1**: Creative Generator (poems, stories) - high temperature\n2. **Type 2**: Knowledge Retrieval (how-to guides) - pattern-based\n3. **Type 3**: Document Store Search (external docs) - scope boundaries\n4. **Type 4**: Analytical Engine (research) - web search enabled\n5. **Type 5**: Hybrid Assistant - LLM fallback with user confirmation\n\n## Historical Context\n\nThe project underwent a **naming standardization in January 2026**:\n- **Directory name**: `eeframe/` kept for git history and Docker volumes\n- **Service names**: `eeframe-app`, `eeframe-*` volumes kept for data preservation\n- **All user-facing content**: Standardized to \"ExFrame\"\n- **Internal code paths**: `generic_framework/` as implementation detail\n\n**Production deployment**: Docker Compose (recommended)\n**Local development**: Clone + `pip install -e .` (editable install)\n**Project identifier**: `exframe` (pyproject.toml package name)\n**License**: Apache License 2.0\n\nExFrame represents a clean, config-driven architecture that separates data (patterns) from transformation logic (plugins), enabling scalable, maintainable knowledge management across diverse domains.",
    "description": "AI-generated from query: What is exframe?",
    "pattern_type": "knowledge",
    "confidence": 0.7,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "What is exframe?",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-02-05T00:13:52.702Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-02-05T00:13:52.711026",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-02-05T00:13:52.711026"
  },
  {
    "id": "exframe_424517e9",
    "pattern_id": "exframe_424517e9",
    "name": "Describe the current version of exframe",
    "domain": "exframe",
    "problem": "Describe the current version of exframe",
    "solution": "Based on the documentation, here's a description of the current version of ExFrame:\n\n## **ExFrame - Current Version Overview**\n\n### **Core Architecture**\nExFrame is a **domain-agnostic, plugin-based knowledge management system** with a **universe-based architecture**. The current implementation features:\n\n1. **Plugin Pipeline Architecture**: Router \u2192 Specialist \u2192 Enricher \u2192 Formatter - all swappable\n2. **Universe System**: Complete isolation and portability of knowledge configurations\n3. **Persona-Based Design** (Phase 1): Replaced complex domain types with three simple personas:\n   - **Poet** (void) - Pure generation with no external sources\n   - **Librarian** (library) - Document search from local library\n   - **Researcher** (internet) - Web search for current information\n\n### **Key Features**\n\n#### **Self-Healing Capabilities**\n- **Contradiction Detection System**: Automatically identifies documentation inconsistencies\n- **Scope Boundaries**: Per-domain configuration to reject out-of-scope queries\n- **Feedback Loop**: Save explanations as patterns \u2192 detector learns context \u2192 finds new contradictions\n\n#### **Plugin System**\n- **Specialist Plugins**: Answer questions in specific domains (implement 3 methods: `can_handle`, `process_query`, `format_response`)\n- **Knowledge Base Plugins**: Store and retrieve patterns (JSON, SQLite backends)\n- **Enricher Plugins**: Transform and enhance responses (LLM synthesis, source formatting)\n- **Router Plugins**: Determine query handling strategies\n- **Formatter Plugins**: Control output format (Markdown, JSON, HTML)\n\n#### **Semantic Search**\n- Pure semantic search using SentenceTransformers embeddings (all-MiniLM-L6-v2)\n- 100% semantic, 0% keyword matching\n- Similarity scores (0-1 range) visible in traces\n\n### **Current Version Details**\n\n**From CHANGELOG.md:**\n- **Phase 1 (2026-02-04)**: Complete replacement of domain types with persona-based architecture\n- **Version 1.6.0 (2026-01-27)**: Domain Type System (now superseded by personas)\n- **Version 1.5.1 (2026-01-24)**: Smart truncation for pattern embeddings, Claude Code Communication API\n- **Version 1.1.0 (2026-01-09)**: Router & Formatter Plugin Systems\n- **Version 1.0.0 (2026-01-09)**: Plugin Architecture Foundation\n\n### **Technical Stack**\n- **Backend**: FastAPI with 45+ routes\n- **Frontend**: Alpine.js SPA with Tailwind CSS\n- **Deployment**: Docker Compose (production), `pip install -e .` (development)\n- **Monitoring**: Prometheus, Grafana, Loki (optional)\n- **License**: Apache License 2.0\n\n### **Current State**\n- **Status**: Phase 1 complete and shipped (February 2026)\n- **Architecture**: ~70% of transformation logic is pluggable\n- **Domains**: 7 production domains with 55+ patterns and 9 specialist plugins\n- **Documentation**: Recently audited and simplified (39 \u2192 20 files)\n\n### **Naming Standardization (January 2026)**\nThe project underwent standardization from \"EEFrame\" to \"ExFrame\":\n- **Directory name**: `eeframe/` kept for git history and Docker volumes\n- **Service names**: `eeframe-app`, `eeframe-*` volumes kept for data preservation\n- **User-facing content**: Standardized to \"ExFrame\" (README, documentation, package name)\n- **Internal code paths**: `generic_framework/` as implementation detail\n\n### **What Makes ExFrame Unique**\n1. **Data as configuration**: Patterns are JSON files, not code\n2. **Plugins for transformation**: All logic is swappable\n3. **Self-healing documentation**: Contradiction detection with feedback loop\n4. **Semantic understanding**: Pure semantic search, no keyword matching\n5. **Universe architecture**: Complete knowledge environment isolation\n\nThe system is designed to be **extensible without code changes** - add new domains by creating JSON patterns and configuration files, not by writing Python classes.",
    "description": "AI-generated from query: Describe the current version of exframe",
    "pattern_type": "knowledge",
    "confidence": 0.7,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "Describe the current version of exframe",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-02-06T00:39:58.930Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-02-06T00:39:58.940527",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-02-06T00:39:58.940527"
  },
  {
    "id": "exframe_7c966a67",
    "pattern_id": "exframe_7c966a67",
    "name": "Explain the query/response cycle for each persona in the form of an odyssey or homeric poem",
    "domain": "exframe",
    "problem": "Explain the query/response cycle for each persona in the form of an odyssey or homeric poem",
    "solution": "**The Odyssey of ExFrame: A Query's Journey Through Three Realms**\n\n**Book I: The Poet's Muse**  \n*Wherein a query finds pure creation in the void*\n\nHear me, O Muse, of the query's first path\u2014  \nThe Poet's realm, where thoughts alone suffice.  \nNo scrolls to search, no web to wander forth,  \nJust patterns from the mind's own inner source.\n\nThe query comes, a suppliant to the shrine,  \nAnd checks first if local patterns align\u2014  \nIf `enable_pattern_override` be true,  \nThe domain's own wisdom it pursues.  \nBut finding none within its bounded store,  \nTo the Poet's void it does implore.\n\nFrom nothingness, the Poet weaves a tale,  \nNo facts constrain, no references prevail.  \nPure generation from the LLM's deep well,  \nWhere only prompts and parameters dwell.  \nA response born of void, yet full and clear\u2014  \nThe Muse's gift to any who draws near.\n\n**Book II: The Librarian's Archive**  \n*Wherein a query seeks wisdom in stored scrolls*\n\nNow sing, O Muse, of shelves that stretch afar\u2014  \nThe Librarian's realm, where knowledge ages are.  \nHere queries wander through the local store,  \n`/app/project/docs` and many more.\n\nFirst checks the patterns\u2014homegrown and refined\u2014  \nThen to the library, with purpose designed.  \nSemantic search through documents arrayed,  \nIn Phase 2's light, where meaning won't fade.  \nEach document a scroll, each file a tome,  \nWithin the local archive's sheltered dome.\n\nThe Librarian weighs each relevant part,  \nWith context drawn from knowledge close at heart.  \nNot current facts, but wisdom tested true\u2014  \nWhat's in the library is what it knew.  \nA response grounded in what's been preserved,  \nFrom patterns stored and carefully observed.\n\n**Book III: The Researcher's Quest**  \n*Wherein a query ventures beyond known shores*\n\nLast sing, O Muse, of boundless seas of data\u2014  \nThe Researcher's realm, where nothing's set or catered.  \nBeyond the walls, across the digital foam,  \nIt seeks what's current, far away from home.\n\nAgain it checks the patterns, first and near,  \nThen launches forth without a trace of fear.  \nAcross the web it casts its searching net,  \nFor information fresh and current yet.  \nWhat happened yesterday, what's happening now\u2014  \nTo this the Researcher makes its solemn vow.\n\nThrough search results it sifts with careful hand,  \nAcross the ever-shifting digital land.  \nA response woven from the present's thread,  \nWith citations from what recently was said.  \nNot just what's stored, but what is happening still\u2014  \nThe Researcher's quest, the modern knowledge-quill.\n\n**Book IV: The Common Thread**  \n*Wherein all journeys share their guiding light*\n\nThree paths diverge, yet all begin the same\u2014  \nWith pattern override, that initial aim.  \n`search_patterns` flag, a toggle in the UI,  \nDecides if local patterns first to try.\n\nThen to their sources, each persona true:  \nThe Poet's void, the Librarian's archive due,  \nThe Researcher's web\u2014each with its proper sphere,  \nReplacing domain types that once were here.  \nNo more the five-fold system, complex, old,  \nBut three clear paths, as has been lately told.\n\nOne decision tree, where once a thousand stood\u2014  \nThis simplification proves itself as good.  \nData from behavior cleanly separated,  \nAs Phase 1's wisdom has demonstrated.\n\nThus ends the query's odyssey through realms three,  \nFrom void to archive to the digital sea.  \nEach persona with its proper domain,  \nBringing order from complexity's chain.  \nThe epic of a system made more clear\u2014  \nThree paths, one journey, conquering each frontier.",
    "description": "AI-generated from query: Explain the query/response cycle for each persona in the form of an odyssey or homeric poem",
    "pattern_type": "knowledge",
    "confidence": 0.7,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "Explain the query/response cycle for each persona in the form of an odyssey or homeric poem",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-02-06T01:33:08.238Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-02-06T01:33:08.244430",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-02-06T01:33:08.244430"
  }
]