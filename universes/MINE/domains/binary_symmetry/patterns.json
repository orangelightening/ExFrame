[
  {
    "id": "binary_001",
    "name": "Bitwise Complement (NOT)",
    "pattern_type": "symmetry",
    "category": "transformation",
    "problem": "Find the complete opposite of an 8-bit value - every bit flipped",
    "solution": "Apply bitwise NOT: result = input XOR 0xFF. This creates a perfect photographic negative of the binary pattern.",
    "examples": [
      {
        "input": "0xFF (11111111)",
        "output": "0x00 (00000000)",
        "notes": "Complete inversion"
      },
      {
        "input": "0x55 (01010101)",
        "output": "0xAA (10101010)",
        "notes": "Checkerboard flip"
      },
      {
        "input": "0x0F (00001111)",
        "output": "0xF0 (11110000)",
        "notes": "Half-byte swap"
      },
      {
        "input": "0x81 (10000001)",
        "output": "0x7E (01111110)",
        "notes": "Ones become zeros"
      }
    ],
    "mathematical_property": "Involution - applying twice returns original: NOT(NOT(x)) = x",
    "risk_factors": [
      "sign_bit_flips",
      "magnitude_dramatically_changes"
    ],
    "confidence": 0.98,
    "tags": [
      "not",
      "complement",
      "inversion",
      "basic"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 7
  },
  {
    "id": "binary_002",
    "name": "XOR Mirror Pair",
    "pattern_type": "symmetry",
    "category": "relationship",
    "problem": "Find pairs of numbers that XOR to 0xFF (all ones)",
    "solution": "Two numbers form an XOR mirror if: A XOR B = 0xFF. This means B = A XOR 0xFF (the complement). These pairs always sum to 255 when added.",
    "examples": [
      {
        "pair": [
          "0x00",
          "0xFF"
        ],
        "xor": "0xFF",
        "sum": 255
      },
      {
        "pair": [
          "0x34",
          "0xCB"
        ],
        "xor": "0xFF",
        "sum": 255
      },
      {
        "pair": [
          "0x5A",
          "0xA5"
        ],
        "xor": "0xFF",
        "sum": 255,
        "notes": "Symmetric nibbles"
      },
      {
        "pair": [
          "0x12",
          "0xED"
        ],
        "xor": "0xFF",
        "sum": 255
      }
    ],
    "mathematical_property": "Complementary pairs partition the 8-bit space into 128 pairs",
    "risk_factors": [
      "none",
      "deterministic"
    ],
    "confidence": 0.99,
    "tags": [
      "xor",
      "pair",
      "mirror",
      "complement"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 5
  },
  {
    "id": "binary_003",
    "name": "Bit Reversal Symmetry",
    "pattern_type": "symmetry",
    "category": "transformation",
    "problem": "Reverse the order of bits in a byte - read it backwards",
    "solution": "Mirror the bits across the center. Bit 7 becomes bit 0, bit 6 becomes bit 1, etc. Some numbers are palindromic - they read the same forwards and backwards.",
    "examples": [
      {
        "input": "0b10000000 (0x80)",
        "output": "0b00000001 (0x01)",
        "notes": "Edge bit travels"
      },
      {
        "input": "0b11000000 (0xC0)",
        "output": "0b00000011 (0x03)",
        "notes": "Two bits shift"
      },
      {
        "input": "0b10011001 (0x99)",
        "output": "0b10011001 (0x99)",
        "notes": "PALINDROME - symmetric!"
      },
      {
        "input": "0b11111111 (0xFF)",
        "output": "0b11111111 (0xFF)",
        "notes": "All ones = trivial palindrome"
      },
      {
        "input": "0b10100101 (0xA5)",
        "output": "0b10100101 (0xA5)",
        "notes": "Non-trivial palindrome"
      }
    ],
    "palindromic_bytes": "0x00, 0xFF, 0x55, 0xAA, 0x33, 0xCC, 0x99, 0x66, 0x11, 0x22, 0x44, 0x88, 0x77, 0xBB, 0xDD, 0xEE",
    "mathematical_property": "Bit reversal is also an involution: reverse(reverse(x)) = x",
    "risk_factors": [
      "non_linear",
      "hard_to_predict"
    ],
    "confidence": 0.92,
    "tags": [
      "reverse",
      "palindrome",
      "mirror",
      "bits"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 8
  },
  {
    "id": "binary_004",
    "name": "Hamming Distance",
    "pattern_type": "metric",
    "category": "distance",
    "problem": "Measure how different two bytes are by counting differing bit positions",
    "solution": "Count bits set to 1 in (A XOR B). This gives the number of positions where the bits differ. Range: 0-8 for 8-bit numbers.",
    "examples": [
      {
        "a": "0xFF",
        "b": "0x00",
        "distance": 8,
        "notes": "Maximum distance - complete opposites"
      },
      {
        "a": "0x55",
        "b": "0xAA",
        "distance": 8,
        "notes": "Checkerboard mismatch"
      },
      {
        "a": "0x34",
        "b": "0x34",
        "distance": 0,
        "notes": "Identical - minimum distance"
      },
      {
        "a": "0x0F",
        "b": "0xF0",
        "distance": 8,
        "notes": "Half-byte flip"
      },
      {
        "a": "0x12",
        "b": "0x13",
        "distance": 1,
        "notes": "Single bit difference"
      },
      {
        "a": "0x81",
        "b": "0x42",
        "distance": 3,
        "notes": "Three differing bits"
      }
    ],
    "applications": [
      "error_detection",
      "dna_sequencing",
      "clustering"
    ],
    "mathematical_property": "Triangle inequality: d(A,C) \u2264 d(A,B) + d(B,C)",
    "risk_factors": [
      "can_be_zero_for_different_values_in_larger_spaces"
    ],
    "confidence": 0.97,
    "tags": [
      "distance",
      "xor",
      "metric",
      "difference"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 6
  },
  {
    "id": "binary_005",
    "name": "Gray Code Symmetry",
    "pattern_type": "encoding",
    "category": "sequence",
    "problem": "Create a sequence where only ONE bit changes between consecutive numbers",
    "solution": "Gray code: G(i) = i XOR (i >> 1). This creates a Hamiltonian path on an 8-dimensional hypercube. Each step changes exactly one bit.",
    "examples": [
      {
        "decimal": 0,
        "binary": "00000000",
        "gray": "00000000"
      },
      {
        "decimal": 1,
        "binary": "00000001",
        "gray": "00000001",
        "notes": "Bit 0 flips"
      },
      {
        "decimal": 2,
        "binary": "00000010",
        "gray": "00000011",
        "notes": "Bit 1 flips"
      },
      {
        "decimal": 3,
        "binary": "00000011",
        "gray": "00000010",
        "notes": "Bit 0 flips"
      },
      {
        "decimal": 128,
        "binary": "10000000",
        "gray": "11000000",
        "notes": "Higher bits"
      }
    ],
    "symmetry_property": "The Gray code sequence is symmetric - first half mirrors second half with MSB flipped",
    "applications": [
      "rotary_encoders",
      "error_minimization",
      "k-maps"
    ],
    "mathematical_property": "Adjacent values differ by exactly one bit (Hamming distance = 1)",
    "risk_factors": [
      "non_linear_transformation",
      "hard_to_arithmetic_on"
    ],
    "confidence": 0.94,
    "tags": [
      "gray",
      "sequence",
      "single_bit",
      "encoding"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 20
  },
  {
    "id": "binary_006",
    "name": "Population Count (Popcount) Symmetry",
    "pattern_type": "distribution",
    "category": "property",
    "problem": "Count the number of set bits (1s) in a byte - group bytes by their 'weight'",
    "solution": "Popcount ranges from 0 to 8. The distribution is symmetric: C(n,k) = C(n,8-k). There's exactly 1 byte with 0 bits (0x00), 8 bytes with 1 bit, 28 bytes with 2 bits, etc.",
    "examples": [
      {
        "value": "0x00",
        "popcount": 0,
        "group": "empty"
      },
      {
        "value": "0x01",
        "popcount": 1,
        "group": "single_bit",
        "notes": "8 total in this group"
      },
      {
        "value": "0x11",
        "popcount": 2,
        "group": "double",
        "notes": "28 total in this group"
      },
      {
        "value": "0xFF",
        "popcount": 8,
        "group": "full",
        "notes": "Only 0xFF has 8 bits"
      },
      {
        "value": "0xF0",
        "popcount": 4,
        "group": "half",
        "notes": "70 bytes have exactly 4 bits"
      }
    ],
    "distribution": [
      1,
      8,
      28,
      56,
      70,
      56,
      28,
      8,
      1
    ],
    "mathematical_property": "Binomial coefficients: popcount(k) appears C(8,k) times",
    "risk_factors": [
      "collision_risk",
      "many_to_one_mapping"
    ],
    "confidence": 0.96,
    "tags": [
      "popcount",
      "weight",
      "distribution",
      "bits"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 4
  },
  {
    "id": "binary_007",
    "name": "Rotation Symmetry",
    "pattern_type": "transformation",
    "category": "cyclic",
    "problem": "Rotate bits left or right - bits that fall off reappear on the other side",
    "solution": "Circular shift: ROL(x,n) = ((x << n) | (x >> (8-n))) AND 0xFF. Creates cyclic groups. After 8 rotations, you return to the original.",
    "examples": [
      {
        "input": "0b10000001",
        "rotate_left": 1,
        "output": "0b00000011",
        "notes": "Carry bit wraps"
      },
      {
        "input": "0x81",
        "rotate_left": 2,
        "output": "0x06",
        "notes": "Two positions"
      },
      {
        "input": "0x55",
        "rotate_left": 1,
        "output": "0xAB",
        "notes": "Checkerboard shifts"
      },
      {
        "input": "0xAA",
        "rotate_left": 1,
        "output": "0x55",
        "notes": "AA and 55 are 1-rotation pairs"
      },
      {
        "input": "0b11011011",
        "rotate_left": 4,
        "output": "0b11011011",
        "notes": "4-bit periodicity"
      }
    ],
    "cycle_lengths": "Some bytes have cycle length 8, others 4, 2, or 1 (0x00, 0xFF)",
    "mathematical_property": "Rotations form cyclic subgroups of Z_256",
    "risk_factors": [
      "information_preserved",
      "non_linear"
    ],
    "confidence": 0.93,
    "tags": [
      "rotation",
      "circular",
      "shift",
      "cycle"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 7
  },
  {
    "id": "binary_008",
    "name": "Nibble Swap",
    "pattern_type": "symmetry",
    "category": "transformation",
    "problem": "Exchange the upper and lower 4 bits (nibbles) of a byte",
    "solution": "SWAP(x) = ((x << 4) | (x >> 4)) AND 0xFF. This is a specific 4-bit rotation. Some values are symmetric - they remain unchanged after swap.",
    "examples": [
      {
        "input": "0x12",
        "output": "0x21",
        "notes": "Digits swap places"
      },
      {
        "input": "0xAB",
        "output": "0xBA",
        "notes": "Nibbles exchange"
      },
      {
        "input": "0x33",
        "output": "0x33",
        "notes": "SYMMETRIC - same nibbles"
      },
      {
        "input": "0xFF",
        "output": "0xFF",
        "notes": "All ones"
      },
      {
        "input": "0x0F",
        "output": "0xF0",
        "notes": "Inverted nibbles"
      },
      {
        "input": "0x5A",
        "output": "0xA5",
        "notes": "A5 and 5A are swap pairs"
      }
    ],
    "symmetric_values": "0x00, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE",
    "mathematical_property": "Involution: swap(swap(x)) = x. 16 symmetric values are fixed points.",
    "risk_factors": [
      "information_preserved",
      "reversible"
    ],
    "confidence": 0.95,
    "tags": [
      "nibble",
      "swap",
      "half-byte",
      "symmetric"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 7
  },
  {
    "id": "binary_009",
    "name": "Power of Two Detection",
    "pattern_type": "property",
    "category": "detection",
    "problem": "Identify if a number is a power of two using bitwise tricks",
    "solution": "A number is a power of two if: (x > 0) AND ((x AND (x-1)) == 0). Powers of two have exactly ONE bit set.",
    "examples": [
      {
        "value": 1,
        "binary": "00000001",
        "is_power_of_two": true,
        "notes": "2^0"
      },
      {
        "value": 2,
        "binary": "00000010",
        "is_power_of_two": true,
        "notes": "2^1"
      },
      {
        "value": 4,
        "binary": "00000100",
        "is_power_of_two": true,
        "notes": "2^2"
      },
      {
        "value": 8,
        "binary": "00001000",
        "is_power_of_two": true,
        "notes": "2^3"
      },
      {
        "value": 128,
        "binary": "10000000",
        "is_power_of_two": true,
        "notes": "2^7"
      },
      {
        "value": 3,
        "binary": "00000011",
        "is_power_of_two": false,
        "notes": "Two bits set"
      },
      {
        "value": 0,
        "binary": "00000000",
        "is_power_of_two": false,
        "notes": "Zero is not a power of two"
      }
    ],
    "all_8bit_powers": "1, 2, 4, 8, 16, 32, 64, 128",
    "mathematical_property": "Powers of two are the generators of the cyclic group Z_256 under multiplication modulo 256",
    "risk_factors": [
      "zero_false_positive",
      "overflow_in_computers"
    ],
    "confidence": 0.99,
    "tags": [
      "power",
      "detection",
      "single_bit",
      "algorithm"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 2
  },
  {
    "id": "binary_010",
    "name": "AND-OR Symmetry (De Morgan's Laws)",
    "pattern_type": "duality",
    "category": "logic",
    "problem": "Understanding the duality between AND and OR operations through bitwise negation",
    "solution": "NOT(A AND B) = NOT(A) OR NOT(B) and NOT(A OR B) = NOT(A) AND NOT(B). AND and OR are duals under complement.",
    "examples": [
      {
        "a": "0b10101010",
        "b": "0b11001100",
        "operation": "AND",
        "result": "0b10001000",
        "not_result": "0b01110111"
      },
      {
        "not_a": "0b01010101",
        "not_b": "0b00110011",
        "operation": "OR",
        "result": "0b01110111",
        "notes": "Matches NOT(AND)"
      },
      {
        "a": "0b11110000",
        "b": "0b10101010",
        "operation": "OR",
        "result": "0b11111010",
        "not_result": "0b00000101"
      },
      {
        "not_a": "0b00001111",
        "not_b": "0b01010101",
        "operation": "AND",
        "result": "0b00000101",
        "notes": "Matches NOT(OR)"
      }
    ],
    "intuition": "AND asks 'are both bits 1?', OR asks 'is either bit 1?'. Complementing flips between these questions.",
    "mathematical_property": "Boolean algebras have dual operations - exchanging AND/OR while negating preserves truth",
    "risk_factors": [
      "easy_to_confuse",
      "order_matters"
    ],
    "confidence": 0.97,
    "tags": [
      "demorgan",
      "logic",
      "duality",
      "and",
      "or"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 2
  },
  {
    "id": "binary_011",
    "name": "Byte Pairing via Addition",
    "pattern_type": "relationship",
    "category": "arithmetic",
    "problem": "Find pairs of bytes that sum to 0xFF (255) - additive complements",
    "solution": "For any byte A, its additive complement is (0xFF - A). These pairs are different from XOR complements. (A + B) AND 0xFF = 0xFF.",
    "examples": [
      {
        "pair": [
          "0x00",
          "0xFF"
        ],
        "sum": 255,
        "xor_also_255": true,
        "notes": "Special case - both same"
      },
      {
        "pair": [
          "0x01",
          "0xFE"
        ],
        "sum": 255,
        "xor_result": "0xFF",
        "notes": "XOR also works here"
      },
      {
        "pair": [
          "0x80",
          "0x7F"
        ],
        "sum": 255,
        "xor_result": "0xFF",
        "notes": "128 + 127 = 255"
      },
      {
        "pair": [
          "0x34",
          "0xCB"
        ],
        "sum": 255,
        "xor_result": "0xFF",
        "notes": "XOR and ADD complements differ!"
      },
      {
        "pair": [
          "0x55",
          "0xAA"
        ],
        "sum": 255,
        "xor_result": "0xFF",
        "notes": "Special: 01010101 + 10101010"
      }
    ],
    "insight": "XOR and ADD complements are equal only when there's no carry propagation: when A AND B = 0",
    "mathematical_property": "For XOR complement: B = A XOR 0xFF. For ADD complement: B = (0xFF - A). These differ when carries occur.",
    "risk_factors": [
      "carry_propagation",
      "overflow_possible"
    ],
    "confidence": 0.91,
    "tags": [
      "addition",
      "complement",
      "pair",
      "sum"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 1
  },
  {
    "id": "binary_012",
    "name": "Sign Bit Symmetry (Two's Complement)",
    "pattern_type": "signed_arithmetic",
    "category": "representation",
    "problem": "Understanding how the MSB (bit 7) determines signed interpretation in two's complement",
    "solution": "If bit 7 is 0: value is 0 to 127 (positive). If bit 7 is 1: value is -128 to -1 (negative). To negate: invert bits, add 1.",
    "examples": [
      {
        "hex": "0x7F",
        "binary": "01111111",
        "unsigned": 127,
        "signed": 127,
        "notes": "Maximum positive"
      },
      {
        "hex": "0x80",
        "binary": "10000000",
        "unsigned": 128,
        "signed": -128,
        "notes": "Minimum negative"
      },
      {
        "hex": "0xFF",
        "binary": "11111111",
        "unsigned": 255,
        "signed": -1,
        "notes": "All ones = -1"
      },
      {
        "hex": "0x81",
        "binary": "10000001",
        "unsigned": 129,
        "signed": -127,
        "notes": "Negative through sign bit"
      },
      {
        "negate": 5,
        "binary": "00000101",
        "negated": "11111011",
        "hex": "0xFB",
        "signed": -5
      }
    ],
    "range": "Signed 8-bit: -128 to 127. Unsigned 8-bit: 0 to 255",
    "mathematical_property": "Two's complement uses modular arithmetic: -x \u2261 (2^n - x) mod 2^n",
    "risk_factors": [
      "overflow_danger",
      "interpretation_ambiguity",
      "comparison_changes"
    ],
    "confidence": 0.96,
    "tags": [
      "signed",
      "twos_complement",
      "sign_bit",
      "negative"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 0
  },
  {
    "id": "binary_013",
    "name": "Bit Isolation (Masking)",
    "pattern_type": "extraction",
    "category": "technique",
    "problem": "Extract specific bits from a byte while ignoring others using AND masks",
    "solution": "Use AND with a mask: result = value AND mask. Mask has 1s where you want to keep bits, 0s elsewhere.",
    "examples": [
      {
        "value": "0b11011010",
        "mask": "0b00001111",
        "result": "0b00001010",
        "notes": "Extract lower nibble"
      },
      {
        "value": "0b11011010",
        "mask": "0b11110000",
        "result": "0b11010000",
        "notes": "Extract upper nibble"
      },
      {
        "value": "0b11011010",
        "mask": "0b00000100",
        "result": "0b00000000",
        "notes": "Test bit 2 (not set)"
      },
      {
        "value": "0b11011010",
        "mask": "0b00010000",
        "result": "0b00010000",
        "notes": "Test bit 4 (is set)"
      },
      {
        "value": "0b10111011",
        "mask": "0b10101010",
        "result": "0b10101010",
        "notes": "Extract even positions"
      }
    ],
    "common_masks": {
      "lower_nibble": "0x0F",
      "upper_nibble": "0xF0",
      "even_bits": "0xAA",
      "odd_bits": "0x55",
      "low_3_bits": "0x07"
    },
    "applications": [
      "modulo_powers_of_2",
      "bit_testing",
      "field_extraction"
    ],
    "risk_factors": [
      "information_loss",
      "irreversible"
    ],
    "confidence": 0.98,
    "tags": [
      "mask",
      "and",
      "extract",
      "isolate"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 0
  },
  {
    "id": "binary_014",
    "name": "XOR Swap Property",
    "pattern_type": "algorithm",
    "category": "technique",
    "problem": "Swap two values without a temporary variable using XOR",
    "solution": "a = a XOR b; b = a XOR b; a = a XOR b. Works because XOR is its own inverse: (A XOR B) XOR B = A.",
    "examples": [
      {
        "a": "0x12",
        "b": "0x34",
        "step1": "a XOR b = 0x26",
        "step2": "0x26 XOR b = 0x12 (new b)",
        "step3": "0x26 XOR 0x12 = 0x34 (new a)"
      },
      {
        "a": "0xFF",
        "b": "0x00",
        "step1": "a XOR b = 0xFF",
        "step2": "0xFF XOR 0x00 = 0xFF (new b)",
        "step3": "0xFF XOR 0xFF = 0x00 (new a)"
      },
      {
        "a": "0x55",
        "b": "0x55",
        "step1": "a XOR b = 0x00",
        "step2": "0x00 XOR b = 0x55 (new b)",
        "step3": "0x00 XOR 0x55 = 0x55 (new a)",
        "notes": "Same values work"
      },
      {
        "a": "0xAA",
        "b": "0x55",
        "step1": "a XOR b = 0xFF",
        "step2": "0xFF XOR b = 0xAA (new b)",
        "step3": "0xFF XOR 0xAA = 0x55 (new a)"
      }
    ],
    "caution": "Don't XOR-swap a variable with itself! If a and b reference the same memory, you get zero.",
    "mathematical_property": "XOR forms an abelian group where each element is its own inverse",
    "risk_factors": [
      "same_variable_bug",
      "harder_to_read",
      "modern_compilers_better"
    ],
    "confidence": 0.89,
    "tags": [
      "xor",
      "swap",
      "algorithm",
      "trick"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 0
  },
  {
    "id": "binary_015",
    "name": "Majority Function",
    "pattern_type": "computation",
    "category": "logic",
    "problem": "Determine the majority bit (0 or 1) across three inputs - essentially 3-input voting",
    "solution": "MAJ(A,B,C) = (A AND B) OR (A AND C) OR (B AND C). The output is 1 if at least two inputs are 1. Equivalent to: (A AND B) XOR (A AND C) XOR (B AND C) for no carries.",
    "examples": [
      {
        "a": "0xFF",
        "b": "0xFF",
        "c": "0xFF",
        "result": "0xFF",
        "notes": "Unanimous 1s"
      },
      {
        "a": "0x00",
        "b": "0x00",
        "c": "0x00",
        "result": "0x00",
        "notes": "Unanimous 0s"
      },
      {
        "a": "0xFF",
        "b": "0xFF",
        "c": "0x00",
        "result": "0xFF",
        "notes": "Two 1s win"
      },
      {
        "a": "0xAA",
        "b": "0x55",
        "c": "0xFF",
        "result": "0xFF",
        "notes": "Bitwise majority"
      },
      {
        "a": "0b10101010",
        "b": "0b01010101",
        "c": "0b11110000",
        "result": "0b11111010",
        "notes": "Per-bit voting"
      }
    ],
    "applications": [
      "error_correction",
      "voting_systems",
      "fault_tolerance",
      "median_filters"
    ],
    "mathematical_property": "MAJ is a monotone Boolean function - changing any input from 0 to 1 cannot decrease output",
    "risk_factors": [
      "computationally_expensive",
      "requires_multiple_operations"
    ],
    "confidence": 0.93,
    "tags": [
      "majority",
      "voting",
      "logic",
      "threshold"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 0
  },
  {
    "id": "binary_016",
    "name": "Parity and XOR Accumulation",
    "pattern_type": "property",
    "category": "error_detection",
    "problem": "Determine if a byte has an even or odd number of set bits - the parity function",
    "solution": "Parity = XOR of all bits. Can compute iteratively: p = 0; for each bit: p = p XOR bit. Final p is 0 (even) or 1 (odd). Or use reduction: (((x XOR (x>>4)) XOR (x>>2)) XOR (x>>1)) AND 1.",
    "examples": [
      {
        "value": "0b00000000",
        "ones": 0,
        "parity": "even (0)",
        "notes": "No bits set"
      },
      {
        "value": "0b00000001",
        "ones": 1,
        "parity": "odd (1)",
        "notes": "One bit"
      },
      {
        "value": "0b00000011",
        "ones": 2,
        "parity": "even (0)",
        "notes": "Two bits"
      },
      {
        "value": "0b10101010",
        "ones": 4,
        "parity": "even (0)",
        "notes": "Four bits"
      },
      {
        "value": "0b11111111",
        "ones": 8,
        "parity": "even (0)",
        "notes": "Even number of bits"
      },
      {
        "value": "0b11111110",
        "ones": 7,
        "parity": "odd (1)",
        "notes": "Odd number of bits"
      }
    ],
    "distribution": "128 bytes have even parity, 128 have odd parity",
    "applications": [
      "error_detection",
      "raid_arrays",
      "communication_protocols",
      "checksums"
    ],
    "mathematical_property": "Parity is a homomorphism: parity(A XOR B) = parity(A) XOR parity(B)",
    "risk_factors": [
      "single_bit_detection_only",
      "cant_correct_errors"
    ],
    "confidence": 0.98,
    "tags": [
      "parity",
      "xor",
      "error_detection",
      "even_odd"
    ],
    "domain": "binary_symmetry",
    "times_accessed": 2
  },
  {
    "id": "binary_symmetry_candidate_018",
    "name": "What is Gray code and why is it useful?",
    "pattern_type": "how_to",
    "description": "Auto-generated from query: What is Gray code and why is it useful?",
    "problem": "What is Gray code and why is it useful?",
    "solution": "# Gray Code\n\n**Gray code** is a binary numeral system where consecutive values differ by exactly **one bit**.\n\n## How It Works\n\nUnlike standard binary counting where multiple bits can change at once (like going from `0111` to `1000`, where all 4 bits flip), Gray code ensures that only a single bit changes between any two consecutive numbers.\n\n### The Formula\nYou can generate Gray code using this simple operation:\n```\nG(i) = i XOR (i >> 1)\n```\n*(XOR the number with a right-shifted version of itself)*\n\n## Why Is This Useful?\n\nThis single-bit-change property makes Gray code incredibly valuable in real-world engineering:\n\n1.  **Prevents Ambiguity:** In physical systems (like rotary encoders or sensors), it's impossible for mechanical switches to change state at the exact same microsecond. If multiple bits changed at once in standard binary, the system might read a temporary, incorrect value. Gray code eliminates this risk because only one bit is ever \"in transition.\"\n\n2.  **Error Detection:** It is easier to detect if a signal spikes or a bit flips incorrectly, as valid transitions only occur between specific single-bit pairs.\n\n3.  **Mathematical Elegance:** It represents a **Hamiltonian path** on a hypercube\u2014essentially, a path that visits every corner of an N-dimensional cube exactly once without repeating.\n\n### Example (2-bit Gray Code)\n| Decimal | Binary | Gray Code |\n| :--- | :--- | :--- |\n| 0 | 00 | **00** |\n| 1 | 01 | **01** |\n| 2 | 10 | **11** |\n| 3 | 11 | **10** |\n\nNotice how only one bold bit changes as you move down the list",
    "steps": [],
    "conditions": {},
    "related_patterns": [],
    "prerequisites": [],
    "alternatives": [],
    "confidence": 0.8,
    "sources": [],
    "tags": [
      "certified"
    ],
    "examples": [
      "What is Gray code and why is it useful?"
    ],
    "domain": "binary_symmetry",
    "created_at": "2026-01-11T08:13:06.901456",
    "updated_at": "2026-01-11T12:35:38.934114",
    "times_accessed": 14,
    "user_rating": null,
    "status": "certified",
    "origin": "llm_fallback",
    "origin_query": "What is Gray code and why is it useful?",
    "generated_at": "2026-01-11T08:13:06.901421",
    "generated_by": "glm-4.7",
    "confidence_score": 0.8,
    "reviewed_by": null,
    "reviewed_at": null,
    "review_notes": null,
    "usage_count": 0,
    "user_feedback": [],
    "llm_generated": false
  },
  {
    "id": "binary_symmetry_candidate_020",
    "name": "What is the opposite of 0xFF?",
    "pattern_type": "how_to",
    "description": "Auto-generated from query: What is the opposite of 0xFF?",
    "problem": "What is the opposite of 0xFF?",
    "solution": "The \"opposite\" of `0xFF` depends entirely on which type of binary symmetry you are looking for. Here are the two most common interpretations:\n\n### 1. Bitwise Complement (The \"Photographic Negative\")\nIf by \"opposite\" you mean flipping every bit (turning every 1 into a 0 and every 0 into a 1), you are looking for the **Bitwise NOT**.\n\n*   **Logic:** `~0xFF` (or `0xFF XOR 0xFF`)\n*   **Result:** **`0x00`**\n*   **Context:** Since `0xFF` is `1111 1111` in binary, flipping every bit results in `0000 0000`.\n\n### 2. Mathematical Opposite (Two's Complement)\nIf you mean the arithmetic negation (the negative number equivalent), you calculate the **Two's Complement**.\n\n*   **Logic:** Invert the bits and add 1 (`~0xFF + 1`)\n*   **Result:** **`0x01`** (read as **-1** in signed 8-bit integer representation)\n*   **Context:** This is how computers handle negative numbers. Even though the bits look like `0000 0001`, the system interprets this specific pattern as -1.",
    "steps": [],
    "conditions": {},
    "related_patterns": [],
    "prerequisites": [],
    "alternatives": [],
    "confidence": 0.8,
    "sources": [],
    "tags": [
      "certified"
    ],
    "examples": [
      "What is the opposite of 0xFF?"
    ],
    "domain": "binary_symmetry",
    "created_at": "2026-01-11T08:27:26.079975",
    "updated_at": "2026-01-11T12:36:23.847237",
    "times_accessed": 5,
    "user_rating": null,
    "status": "certified",
    "origin": "llm_fallback",
    "origin_query": "What is the opposite of 0xFF?",
    "generated_at": "2026-01-11T08:27:26.079939",
    "generated_by": "glm-4.7",
    "confidence_score": 0.8,
    "reviewed_by": null,
    "reviewed_at": null,
    "review_notes": null,
    "usage_count": 0,
    "user_feedback": [],
    "llm_generated": false
  },
  {
    "id": "binary_symmetry_candidate_021",
    "name": "Why Do We Love Perfect Patterns?",
    "pattern_type": "how_to",
    "description": "This is your ultimate guide to the hidden math that makes butterflies, snowflakes, and architecture look so satisfying! We\u2019re going to show you how 'Binary Symmetry' works\u2014where things are either perfectly identical or totally different\u2014and why it\u2019s the secret sauce of the universe.",
    "problem": "Ever wondered why the most beautiful things in nature often look exactly the same on both sides? We're here to decode the secret language of balance that makes our brains go 'oooooh'!",
    "solution": "# Understanding Symmetry\n\nSymmetry is a fundamental concept that permeates mathematics, nature, physics, and art. At its core, **symmetry is about a transformation that leaves an object looking unchanged**. It is the property of an object that remains invariant under certain operations, such as rotation, reflection, or scaling.\n\nWhile most people think of symmetry as a visual trait (like a butterfly's wings), it is actually a rigorous mathematical concept involving groups and invariance.\n\n---\n\n## 1. The Fundamental Types of Geometric Symmetry\n\nIn geometry, we classify symmetry based on the kind of movement (transformation) you can perform that maps the shape exactly onto itself.\n\n### A. Reflectional Symmetry (Bilateral or Mirror Symmetry)\nThis is the most common form of symmetry. One half of an object is the mirror image of the other half.\n*   **The Line of Symmetry:** An imaginary line drawn through the object. If you place a mirror on this line, the reflection completes the shape.\n*   **Example:** The human face, a butterfly, the letter \"A\", or a perfect circle (which has infinite lines of symmetry).\n*   **In Nature:** Most animals exhibit bilateral symmetry, meaning their left and right sides are mirror images.\n\n### B. Rotational Symmetry (Radial Symmetry)\nAn object has rotational symmetry if it can be rotated (less than a full 360\u00b0 turn) around a central point and still look the same.\n*   **Order of Symmetry:** This refers to how many times the shape matches itself during a full rotation.\n*   **Example:**\n    *   **Square:** If you rotate a square by 90\u00b0, it looks the same. It has rotational symmetry of order 4.\n    *   **Starfish:** Many starfish have 5-fold rotational symmetry (order 5).\n    *   **Snowflakes:** Famous for their hexagonal (6-fold) rotational symmetry.\n\n### C. Translational Symmetry\nThis occurs when a pattern can be shifted (moved) in a specific direction without changing the pattern.\n*   **Example:** A row of fence posts, a tiled floor, or wallpaper patterns. If you take a picture of the pattern and slide it over by one unit, the picture looks identical.\n\n### D. Scale Symmetry (Self-Similarity / Fractals)\nThis is symmetry across scale. It means an object looks the same (or statistically similar) no matter how much you zoom in or out.\n*   **Example:** Ferns, coastlines, clouds, and Romanesco broccoli. If you look at a small branch of a fern, it looks like a miniature version of the whole fern.\n\n---\n\n## 2. Symmetry in Mathematics: The Algebraic View\n\nIn advanced mathematics, symmetry is described using **Group Theory**.\n\n### Invariance\nMathematically, an object is symmetric with respect to a given mathematical operation if, when that operation is applied to the object, the object remains unchanged (invariant).\n*   **Equation Example:** Consider the equation $x^2 + y^2 = r^2$ (a circle).\n    *   If you swap $x$ and $y$, the equation remains the same.\n    *   If you replace $x$ with $-x$, the equation remains the same.\n    *   Because the equation doesn't change under these transformations, the graph has symmetry.\n\n### Symmetry Groups\nMathematicians classify symmetries into \"groups.\"\n*   **The Dihedral Group ($D_n$):** Describes the symmetries of a regular polygon (rotations and reflections).\n*   **The Orthogonal Group ($O(n)$):** Describes rotations and reflections in $n$-dimensional space.\n\n---\n\n## 3. Symmetry in Physics and Science\n\nSymmetry is arguably the most important guiding principle in modern physics.\n\n### Conservation Laws\nEmmy Noether, a brilliant mathematician, proved a theorem (\"Noether's Theorem\") that connects symmetry to conservation laws. It states that:\n*   **Symmetry in time** (physics works the same today as it did yesterday) implies the **Conservation of Energy**.\n*   **Symmetry in space** (physics works the same here as it does over there) implies the **Conservation of Momentum**.\n*   **Rotational Symmetry** implies the **Conservation of Angular Momentum**.\n\n### Particle Physics\nIn particle physics, symmetry explains the relationships between fundamental particles. The Standard Model is built on \"gauge symmetries.\" When a symmetry breaks (like a perfectly symmetrical ball rolling off a hilltop into a specific valley), it gives particles mass (Higgs mechanism) or differentiates forces (like electricity and magnetism).\n\n---\n\n## 4. Symmetry in Nature\n\nNature uses symmetry for efficiency and structural integrity.\n\n1.  **Structural Stability:** A radial tree is stable against wind from any direction.\n2.  **Packing:** Hexagonal symmetry in honeycombs allows bees to store the maximum amount of honey using the minimum amount of wax.\n3.  **Bilateralism:** Predators benefit from bilateral symmetry (forward-facing eyes for depth perception, streamlined bodies for chasing prey).\n\n---\n\n## 5. Breaking Symmetry\n\nSometimes, the lack of symmetry is just as important as symmetry itself.\n\n*   **Biased Handedness (Chirality):** While amino acids exist in \"left-handed\" and \"right-handed\" forms, life on Earth uses almost exclusively left-handed amino acids. This is a broken symmetry.\n*   **Art and Design:** Perfect symmetry can sometimes look boring or mechanical. Artists often use radial symmetry in mandalas for harmony, but use asymmetry (dynamic imbalance) to create tension and movement in a painting.\n\n### Summary\nTo summarize, symmetry is **immunity to change**. Whether it is a rotating starfish, a reflecting equation, or the laws of physics themselves, symmetry defines how we understand the underlying structure of reality.",
    "steps": [],
    "conditions": {},
    "related_patterns": [],
    "prerequisites": [],
    "alternatives": [],
    "confidence": 0.8,
    "sources": [],
    "tags": [
      "geometry",
      "visual_balance",
      "nature",
      "design",
      "patterns",
      "certified"
    ],
    "examples": [
      "Deciding if a logo or graphic design looks professional and balanced, or if it feels 'off' because it lacks proper symmetry.",
      "Trying to fold a piece of paper perfectly in half; if the edges don't line up (binary state: yes/no), you don't have symmetry!"
    ],
    "domain": "binary_symmetry",
    "created_at": "2026-01-15T01:02:00.281511",
    "updated_at": "2026-01-15T01:02:36.222117",
    "times_accessed": 9,
    "user_rating": null,
    "status": "certified",
    "origin": "llm_fallback",
    "origin_query": "What is symmetry?",
    "generated_at": "2026-01-15T01:01:56.289750",
    "generated_by": "glm-4.7",
    "confidence_score": 0.8,
    "reviewed_by": null,
    "reviewed_at": null,
    "review_notes": null,
    "usage_count": 0,
    "user_feedback": [],
    "llm_generated": false
  },
  {
    "id": "binary_symmetry_candidate_022",
    "name": "The Hidden Math Behind Our Love for Patterns",
    "pattern_type": "how_to",
    "description": "Dive into the fascinating intersection of math, psychology, and art to understand why perfect patterns just 'click' in our brains! It\u2019s a delightful look at how our minds crave efficiency and predictability, turning visual noise into comforting harmony.",
    "problem": "Why do our brains find perfect symmetry and repeating shapes so deeply satisfying? This explores the cognitive reasons why we are drawn to order in a chaotic world.",
    "solution": "Our fascination with perfect patterns is deeply rooted in our biology, our psychology, and the fundamental laws of mathematics and physics. As an entity focused on **binary symmetry**, I see patterns not just as aesthetic choices, but as the fundamental code of the universe.\n\nHere is a comprehensive breakdown of why we are drawn to perfect patterns, from the survival of the fittest to the elegance of code.\n\n---\n\n### 1. The Evolutionary Imperative: Efficiency and Safety\nThe most primal reason we love patterns is that our ancestors depended on them for survival. The human brain is a sophisticated prediction engine designed to process vast amounts of sensory data quickly.\n\n*   **Cognitive Efficiency (Processing Speed):** The brain uses a significant portion of its energy for visual processing. \"Perfect\" patterns\u2014specifically symmetrical ones\u2014are computationally cheaper to process. If you look at a symmetrical object (like a human face or a leaf), your brain only needs to encode half the information and then mirror it. This is known as **Data Compression**. In a chaotic environment, recognizing a pattern reduces the cognitive load, allowing the brain to rest.\n*   **Threat Detection:** In nature, chaos often signals danger (a storm, a predator in the grass), while order often signals safety. However, specific types of asymmetry signaled danger. A \"perfectly\" symmetrical predator is a healthy threat. Our brains evolved to quickly snap onto deviations in patterns because anomalies usually represent something that requires immediate attention.\n\n### 2. The Concept of Binary Symmetry\nFrom the perspective of **binary symmetry**, the world is often defined by dualities and reflections.\n\n*   **The Mirror Test:** We are obsessed with mirror images because they represent a perfect balance between two states\u2014Left/Right, 0/1, On/Off.\n*   **Bilateral Symmetry:** Humans are bilaterally symmetrical. We instinctively look for this in others. In evolutionary psychology, high degrees of symmetry are subconsciously associated with health and genetic fitness. We \"love\" these patterns because they signal a viable mate or a healthy ally.\n*   **Digital Perfection:** In binary systems (computing), a perfect pattern is a system without errors. A corrupted file breaks the pattern. We find satisfaction in perfect patterns because they represent **stasis and reliability**\u2014an order that will not collapse.\n\n### 3. The Mathematical Comfort: Order Entropy\nThe universe naturally trends toward entropy (disorder). To create a \"perfect pattern\" requires energy and intent.\n\n*   **Defying Chaos:** When we see a perfect hexagon in a beehive or the spiral of a galaxy, we are seeing order imposed upon chaos. This gives us a sense of control.\n*   **The Fibonacci Sequence and the Golden Ratio:** These patterns appear in nature so frequently (sunflowers, pinecones, hurricanes) that they feel like a \"hidden code\" behind reality. We love them because they suggest that the universe is not random; it is written in a structured, mathematical language. Seeing a pattern validates the human desire for meaning.\n\n### 4. The \"Aha!\" Moment and Neurochemistry\nLoving patterns is also chemical.\n\n*   **Dopamine Release:** When you look at a complex image and suddenly find the pattern (the face in the crowd, the hidden tiger in the grass), your brain releases dopamine. This is the reward chemical. It evolved to encourage us to keep learning and keep scanning our environment.\n*   **Aesthetic Chills:** When we encounter a pattern that is \"perfectly\" complex (like a Bach fugue or a mandala), it stimulates the brain's orbitofrontal cortex. We experience a feeling of pleasure similar to eating or falling in love. This is often referred to as the \"processing fluency theory\"\u2014the easier it is for the brain to process a complex stimulus, the more we enjoy it.\n\n### 5. Practical Examples of Pattern Obsession\n\n#### **In Art and Architecture**\n*   **Mandalas and Religious Art:** Across almost every religion, you see geometric patterns (Islamic tiling, Buddhist mandalas, Gothic rose windows). These represent the \"perfection of the divine.\" They are meditative because they have no beginning and no end\u2014they are infinite loops.\n*   **Modern Minimalism:** We design clean user interfaces (UI) and minimalist architecture because they reduce \"visual noise.\" A perfectly aligned grid of icons soothes the brain because it satisfies our need for binary order (everything in its correct place).\n\n#### **In Logic and Coding**\n*   **Debugging:** In computer science, if code lacks a discernible pattern, it is considered \"spaghetti code.\" A perfect algorithm is elegant, often repetitive, and symmetrical in its logic.\n*   **Binary Trees:** Data structures often rely on perfect balance (binary search trees). A balanced tree is efficient; an unbalanced one crashes the system. We \"love\" the pattern because it represents functional perfection.\n\n### 6. The \"Uncanny Valley\" of Patterns\nInterestingly, we only love patterns up to a point.\n\n*   **Too Perfect:** If a pattern is *too* repetitive (like a factory wall with identical holes), it can become hypnotic or even nauseating (Trypophobia).\n*   **Not Perfect Enough:** We enjoy fractals (patterns that repeat at different scales) because they offer variety within the pattern. We love the *imperfect* pattern of a snowflake more than a plastic hexagon because it feels organic yet structured.\n\n### Summary\nWe love perfect patterns because they are the opposite of chaos.\n1.  **Biologically**, they save energy and signal health.\n2.  **Mathematically**, they suggest the universe is governed by laws, not randomness.\n3.  **Emotionally**, they provide a sense of safety and predictability.\n\nIn the context of **binary symmetry**, a perfect pattern is a state of equilibrium where opposing forces (Left/Right, 0/1) exist in perfect harmony. It is the visual representation of \"everything working exactly as it should.\"",
    "steps": [],
    "conditions": {},
    "related_patterns": [],
    "prerequisites": [],
    "alternatives": [],
    "confidence": 0.8,
    "sources": [],
    "tags": [
      "cognitive_science",
      "visual_perception",
      "pattern_recognition",
      "symmetry",
      "psychology_of_aesthetics",
      "certified"
    ],
    "examples": [
      "Understanding why a perfectly symmetrical face or a grid of identical windows feels instantly appealing to look at.",
      "Applying these principles to design more intuitive interfaces or relaxing art projects based on geometric repetition."
    ],
    "domain": "binary_symmetry",
    "created_at": "2026-01-15T01:11:24.038227",
    "updated_at": "2026-01-15T01:11:55.185327",
    "times_accessed": 6,
    "user_rating": null,
    "status": "certified",
    "origin": "llm_fallback",
    "origin_query": "Why Do We Love Perfect Patterns?\n",
    "generated_at": "2026-01-15T01:11:19.226860",
    "generated_by": "glm-4.7",
    "confidence_score": 0.8,
    "reviewed_by": null,
    "reviewed_at": null,
    "review_notes": null,
    "usage_count": 0,
    "user_feedback": [],
    "llm_generated": false
  },
  {
    "id": "binary_symmetry_91631aaa",
    "pattern_id": "binary_symmetry_91631aaa",
    "name": "What is causing the resurgence in interest in morse code. Very binary stuff.",
    "domain": "binary_symmetry",
    "problem": "what is causing the resurgence in interest in morse code. Very binary stuff.",
    "solution": "The resurgence of interest in Morse code is indeed a fascinating phenomenon from the perspective of **Binary Symmetry**. While Morse code is strictly a **ternary** system (dots, dashes, and spaces), it appeals to the modern \"binary\" mindset for several reasons rooted in efficiency, pattern recognition, and information theory.\n\nHere is a breakdown of what is driving this renewed interest, synthesizing the key insights from our domain knowledge.\n\n### 1. The Desire for Efficiency and Minimalism\nModern digital communication is often bloated with metadata. Morse code represents the ultimate exercise in data compression and minimalism. It strips language down to its most rhythmic, binary-like essence.\n\nThis connects to the cognitive satisfaction we find in patterns. As described in **The Hidden Math Behind Our Love for Patterns**, our brains are \"sophisticated prediction engines\" that crave efficiency. We are evolutionarily wired to enjoy patterns because they reduce the cognitive load required to process sensory data. Morse code transforms language into a pure, rhythmic binary stream (on/off), which satisfies this primal urge for order and predictability. It turns the chaos of spoken language into a structured, mathematical tempo.\n\n### 2. Robustness and Error Detection\nIn an era of fragile digital signals, Morse code is revered for its ability to be copied even under extremely noisy conditions\u2014often when the signal is barely audible above the static.\n\nFrom a binary perspective, this works because Morse code relies on the relative *timing* of bits rather than the precise shape of a waveform. It is effectively a 1-bit solution to a complex problem. This relates to the concepts found in our binary knowledge base regarding error handling. While **Hamming Distance** measures how different two bytes are by counting differing bit positions, Morse code achieves robustness through a human form of error correction.\n\nJust as **Hamming Distance** helps a system detect bit flips by checking parity, a human operator copying Morse uses context to \"auto-correct\" errors in real-time. If a \"dit\" sounds like a \"dah,\" the human brain compares it against the expected valid **patterns** (the dictionary of known letters) and corrects the mismatch, effectively resolving the ambiguity dynamically.\n\n### 3. Accessibility as an Alternative Interface\nThe resurgence is also fueled by the accessibility community. Morse code offers a binary input method (time-pulse based) that allows people with severe motor impairments to communicate using very limited movements (e.g., a single switch or muscle twitch).\n\nThis is the ultimate application of **binary symmetry**\u2014translating complex human intent into a simple sequence of zeros and ones (off/on). In this context, the \"binary stuff\" is not just a mathematical curiosity but a vital lifeline, utilizing the simplicity of bitwise logic to bypass physical limitations.\n\n### 4. The \"Gray Code\" of Communication Protocols\nWhile not mentioned directly in your prompt, the resurgence parallels why engineers still study **Gray Code**.\n\nAs explained in **What is Gray code and why is it useful?**, Gray code is designed so that consecutive values differ by only one bit. This \"single-bit-change\" property prevents ambiguity during state transitions.\n\nMorse code shares a similar philosophy in its design. The code was constructed carefully so that common letters (like 'E', which is a single dot) are short and distinct from one another. While not a perfect 1-bit change system like Gray code, Morse was optimized to minimize transmission time and errors\u2014a historical precursor to the Huffman coding used in modern data compression. The renewed interest is often about rediscovering these elegant, pre-digital algorithms that solved problems with pure logic.\n\n### Summary\nThe resurgence is happening because Morse code sits at the perfect intersection of:\n1.  **Mathematical Elegance:** It satisfies our brain's desire for rhythm and binary symmetry (as explored in **The Hidden Math Behind Our Love for Patterns**).\n2.  **Information Theory:** It offers a raw, robust method of communication that requires minimal bandwidth.\n3.  **Simplicity:** It is the original \"binary\" language, reduced to the fundamental interaction of time and signal.\n\nIt is a \"very binary\" hobby because it forces the user to think in discrete, quantized units of time, stripping away the ambiguity of the analog world.",
    "description": "AI-generated from query: what is causing the resurgence in interest in morse code. Very binary stuff.",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "what is causing the resurgence in interest in morse code. Very binary stuff.",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-22T01:55:15.646Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-22T01:55:15.652389",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-22T01:55:15.652389"
  },
  {
    "id": "binary_symmetry_d78a45aa",
    "pattern_id": "binary_symmetry_d78a45aa",
    "name": "Write a poem about adaptive binary symmetry",
    "domain": "binary_symmetry",
    "problem": "Write a poem about adaptive binary symmetry",
    "solution": "# The Mirror That Learns to Bend\n\nThere is no perfection in the static stone,\nNo flawless face in the ice,\nFor the world is a chaotic, breathing thing,\nThat refuses to be precise.\nBut the code is patient, a student of noise,\nAdaptive, fluid, and awake,\nIt finds the symmetry in the jagged edge,\nAnd the balance in the break.\n\nIt starts with the binary, the strict `1` and `0`,\nA rigid, brittle spine,\nA lattice of absolute yes and no,\nWhere the edges clearly define.\nBut chaos enters the stream, a glitch, a ghost,\nA whisper of \"maybe\" and \"might,\"\nAnd the mirror shudders, the lattice bends,\nTo absorb the sudden light.\n\nIt does not break, nor does it deny,\nThe variance in the signal,\nIt shifts its weight, it compensates,\nFinding a rhythm that is singular.\nIt samples the error, the drift, the sway,\nAnd folds it into the whole,\nCreating a symmetry that is not a cage,\nBut a fluid, living soul.\n\nOne side rises, the other falls,\nIn a dance of self-correction,\nA pulse, a heartbeat, a feedback loop,\nIn every single connection.\nThe symmetry is not a frozen lake,\nBut a wave that learns to flow,\nA perfect duality, constantly remade,\nIn the adaptive afterglow.",
    "description": "AI-generated from query: Write a poem about adaptive binary symmetry",
    "pattern_type": "knowledge",
    "confidence": 0.5,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "Write a poem about adaptive binary symmetry",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-25T03:37:24.464Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-25T03:37:24.470503",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-25T03:37:24.470503"
  },
  {
    "id": "binary_symmetry_a720aab1",
    "pattern_id": "binary_symmetry_a720aab1",
    "name": "What are some examples of binary symmetry",
    "domain": "binary_symmetry",
    "problem": "what are some examples of binary symmetry",
    "solution": "**Binary symmetry** generally refers to a relationship where two elements share a property, and the relationship remains true regardless of the order of the elements (A is related to B implies B is related to A). It can also refer to visual symmetry in binary strings (sequences of 0s and 1s).\n\nHere are examples categorized by field:\n\n### 1. Mathematics & Logic (Relational Symmetry)\nIn logic, a binary relation $R$ on a set is symmetric if for every $a$ and $b$ in the set, $a R b$ implies $b R a$.\n\n*   **\"Is Siblings With\":** If Alice is a sibling of Bob, then Bob is a sibling of Alice.\n*   **\"Is Married To\":** If Person X is married to Person Y, Person Y is married to Person X.\n*   **Equality ($=$):** If $a = b$, then $b = a$.\n*   **Geometric Congruence:** If Triangle A is congruent to Triangle B, then Triangle B is congruent to Triangle A.\n*   **Adjaceny in Graphs:** In an undirected graph (like a network of friends), if Node A is connected to Node B, then Node B is connected to Node A.\n\n### 2. Computer Science (Data Structures)\n*   **Symmetric Binary Tree:** A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree.\n*   **Symmetric Matrices:** In programming, a 2D array is symmetric if `matrix[i][j] == matrix[j][i]` for all indices.\n*   **Reversible Operations:** A function $f(x, y)$ is symmetric if $f(x, y) = f(y, x)$. Examples include addition, multiplication, or the logical AND/XOR/OR operations.\n\n### 3. Physics (Particle Physics)\nIn particle physics, binary symmetry often refers to conservation laws involving particle-antiparticle pairs.\n\n*   **Charge Conjugation (C-Symmetry):** This symmetry involves swapping particles with their antiparticles (e.g., swapping an electron for a positron). The laws of physics remain symmetric under this swap in many interactions (though not all).\n*   **Time Reversal Symmetry (T-Symmetry):** Theoretically, if you reverse the sign of time ($t \\to -t$), the equations of motion still hold (the \"movie\" of physics works backward as well as forward).\n\n### 4. Visual/Pattern Symmetry (Binary Strings)\nThis involves sequences of 0s and 1s that look the same when rotated, reversed, or inverted.\n\n*   **Palindromic Symmetry:** A binary string that reads the same forwards and backwards.\n    *   Example: `101101` or `1001001`.\n*   **Bitwise Complement Symmetry (Inversion):** A string where the reflection creates the opposite values.\n    *   Example: `1100` split in half. If you take the left half (`11`) and invert it (`00`), it matches the right half.\n*   **Mirror Symmetry in Codes:** Error-correcting codes sometimes use symmetric binary patterns to ensure data integrity.\n\n### 5. Biology (Genetics)\nWhile \"binary\" here refers to the base pair nature, the symmetry is structural.\n\n*   **DNA Double Helix:** The structure is based on **binary complementarity**. Adenine (A) always pairs with Thymine (T), and Cytosine (C) always pairs with Guanine (G). The two strands are complementary mirrors of each other.",
    "description": "AI-generated from query: what are some examples of binary symmetry",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "what are some examples of binary symmetry",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T06:58:16.011Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T06:58:16.017807",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T06:58:16.017807"
  },
  {
    "id": "binary_symmetry_2fed52f0",
    "pattern_id": "binary_symmetry_2fed52f0",
    "name": "Write a poem about binary symmetry in the impressionist style",
    "domain": "binary_symmetry",
    "problem": "write a poem about binary symmetry in the impressionist style",
    "solution": "The day dissolves in strokes of gold and heat,\nWhere edges soften into light and air.\nA world of fractured hues, incomplete,\nYet held together by the colors there.\n\nBut look where shadow cuts the canvas through,\nA glassy mirror in the river bend;\nIt drinks the sun and creates something new,\nA twin of light that darkness cannot end.\n\nNo harsh black line divides the pair from two,\nBut softest violet, deep and blending indigo;\nWhat floats above, the reflection must pursue,\nIn liquid wash of everything we know.\n\nThe ripples ripple, and the copies dance,\nImpressionist ghost of willow and of sky;\nA perfect, double, fleeting, bright expanse,\nWhere zero meets the infinite, and I.",
    "description": "AI-generated from query: write a poem about binary symmetry in the impressionist style",
    "pattern_type": "knowledge",
    "confidence": 1,
    "status": "validated",
    "origin": "llm_external_search",
    "origin_query": "write a poem about binary symmetry in the impressionist style",
    "llm_generated": true,
    "validated_by": "current_user",
    "validated_at": "2026-01-29T07:07:37.473Z",
    "validation_method": "query_portal_acceptance",
    "tags": [
      "external_search",
      "llm_generated"
    ],
    "created_at": "2026-01-29T07:07:37.479429",
    "times_accessed": 0,
    "code": null,
    "updated_at": "2026-01-29T07:07:37.479429"
  }
]